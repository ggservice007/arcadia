// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	ApplicationMutation() ApplicationMutationResolver
	ApplicationQuery() ApplicationQueryResolver
	DataProcessMutation() DataProcessMutationResolver
	DataProcessQuery() DataProcessQueryResolver
	Dataset() DatasetResolver
	DatasetMutation() DatasetMutationResolver
	DatasetQuery() DatasetQueryResolver
	DatasourceMutation() DatasourceMutationResolver
	DatasourceQuery() DatasourceQueryResolver
	EmbedderMutation() EmbedderMutationResolver
	EmbedderQuery() EmbedderQueryResolver
	KnowledgeBaseMutation() KnowledgeBaseMutationResolver
	KnowledgeBaseQuery() KnowledgeBaseQueryResolver
	LLMQuery() LLMQueryResolver
	Model() ModelResolver
	ModelMutation() ModelMutationResolver
	ModelQuery() ModelQueryResolver
	ModelServiceMutation() ModelServiceMutationResolver
	ModelServiceQuery() ModelServiceQueryResolver
	Mutation() MutationResolver
	Query() QueryResolver
	VersionedDataset() VersionedDatasetResolver
	VersionedDatasetMutation() VersionedDatasetMutationResolver
	VersionedDatasetQuery() VersionedDatasetQueryResolver
	WorkerMutation() WorkerMutationResolver
	WorkerQuery() WorkerQueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Application struct {
		ConversionWindowSize func(childComplexity int) int
		DocNullReturn        func(childComplexity int) int
		Knowledgebase        func(childComplexity int) int
		Llm                  func(childComplexity int) int
		MaxLength            func(childComplexity int) int
		Metadata             func(childComplexity int) int
		Model                func(childComplexity int) int
		NumDocuments         func(childComplexity int) int
		Prologue             func(childComplexity int) int
		ScoreThreshold       func(childComplexity int) int
		ShowNextGUID         func(childComplexity int) int
		Temperature          func(childComplexity int) int
		UserPrompt           func(childComplexity int) int
	}

	ApplicationMetadata struct {
		Annotations       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ID                func(childComplexity int) int
		Icon              func(childComplexity int) int
		IsPublic          func(childComplexity int) int
		Labels            func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Status            func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	ApplicationMutation struct {
		CreateApplication       func(childComplexity int, input CreateApplicationMetadataInput) int
		DeleteApplication       func(childComplexity int, input DeleteCommonInput) int
		UpdateApplication       func(childComplexity int, input UpdateApplicationMetadataInput) int
		UpdateApplicationConfig func(childComplexity int, input UpdateApplicationConfigInput) int
	}

	ApplicationQuery struct {
		GetApplication          func(childComplexity int, name string, namespace string) int
		ListApplicationMetadata func(childComplexity int, input ListCommonInput) int
	}

	CountDataProcessItem struct {
		Data    func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	DataProcessConfig struct {
		Children    func(childComplexity int) int
		Description func(childComplexity int) int
		FileNum     func(childComplexity int) int
		Name        func(childComplexity int) int
		Status      func(childComplexity int) int
	}

	DataProcessConfigChildren struct {
		Description  func(childComplexity int) int
		Enable       func(childComplexity int) int
		FileProgress func(childComplexity int) int
		LlmConfig    func(childComplexity int) int
		Name         func(childComplexity int) int
		Preview      func(childComplexity int) int
		ZhName       func(childComplexity int) int
	}

	DataProcessConfigpreFileProgress struct {
		EndTime   func(childComplexity int) int
		FileName  func(childComplexity int) int
		ID        func(childComplexity int) int
		Progress  func(childComplexity int) int
		StartTime func(childComplexity int) int
		Status    func(childComplexity int) int
	}

	DataProcessConfigpreView struct {
		Content  func(childComplexity int) int
		FileName func(childComplexity int) int
	}

	DataProcessConfigpreViewContent struct {
		Post func(childComplexity int) int
		Pre  func(childComplexity int) int
	}

	DataProcessDetails struct {
		Data    func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	DataProcessDetailsItem struct {
		Config             func(childComplexity int) int
		Creator            func(childComplexity int) int
		EndTime            func(childComplexity int) int
		ErrorMsg           func(childComplexity int) int
		FileNum            func(childComplexity int) int
		FileType           func(childComplexity int) int
		ID                 func(childComplexity int) int
		Name               func(childComplexity int) int
		PostDatasetName    func(childComplexity int) int
		PostDatasetVersion func(childComplexity int) int
		PreDatasetName     func(childComplexity int) int
		PreDatasetVersion  func(childComplexity int) int
		StartTime          func(childComplexity int) int
		Status             func(childComplexity int) int
	}

	DataProcessItem struct {
		ErrorMsg           func(childComplexity int) int
		ID                 func(childComplexity int) int
		Name               func(childComplexity int) int
		PostDataSetName    func(childComplexity int) int
		PostDataSetVersion func(childComplexity int) int
		PreDataSetName     func(childComplexity int) int
		PreDataSetVersion  func(childComplexity int) int
		StartDatetime      func(childComplexity int) int
		Status             func(childComplexity int) int
	}

	DataProcessMutation struct {
		CreateDataProcessTask func(childComplexity int, input *AddDataProcessInput) int
		DeleteDataProcessTask func(childComplexity int, input *DeleteDataProcessInput) int
	}

	DataProcessQuery struct {
		AllDataProcessListByCount func(childComplexity int, input *AllDataProcessListByCountInput) int
		AllDataProcessListByPage  func(childComplexity int, input *AllDataProcessListByPageInput) int
		CheckDataProcessTaskName  func(childComplexity int, input *CheckDataProcessTaskNameInput) int
		DataProcessDetails        func(childComplexity int, input *DataProcessDetailsInput) int
		DataProcessSupportType    func(childComplexity int) int
	}

	DataProcessResponse struct {
		Data    func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	DataProcessSupportType struct {
		Data    func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	DataProcessSupportTypeChildren struct {
		Description func(childComplexity int) int
		Enable      func(childComplexity int) int
		Name        func(childComplexity int) int
		ZhName      func(childComplexity int) int
	}

	DataProcessSupportTypeItem struct {
		Children    func(childComplexity int) int
		Description func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	Dataset struct {
		Annotations       func(childComplexity int) int
		ContentType       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		Field             func(childComplexity int) int
		Labels            func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
		Versions          func(childComplexity int, input ListVersionedDatasetInput) int
	}

	DatasetMutation struct {
		CreateDataset  func(childComplexity int, input *CreateDatasetInput) int
		DeleteDatasets func(childComplexity int, input *DeleteCommonInput) int
		UpdateDataset  func(childComplexity int, input *UpdateDatasetInput) int
	}

	DatasetQuery struct {
		GetDataset   func(childComplexity int, name string, namespace string) int
		ListDatasets func(childComplexity int, input *ListDatasetInput) int
	}

	Datasource struct {
		Annotations       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		Endpoint          func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Oss               func(childComplexity int) int
		Status            func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	DatasourceMutation struct {
		CreateDatasource  func(childComplexity int, input CreateDatasourceInput) int
		DeleteDatasources func(childComplexity int, input *DeleteCommonInput) int
		UpdateDatasource  func(childComplexity int, input *UpdateDatasourceInput) int
	}

	DatasourceQuery struct {
		CheckDatasource func(childComplexity int, input CreateDatasourceInput) int
		GetDatasource   func(childComplexity int, name string, namespace string) int
		ListDatasources func(childComplexity int, input ListCommonInput) int
	}

	Embedder struct {
		Annotations       func(childComplexity int) int
		BaseURL           func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		Models            func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Provider          func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	EmbedderMutation struct {
		CreateEmbedder  func(childComplexity int, input CreateEmbedderInput) int
		DeleteEmbedders func(childComplexity int, input *DeleteCommonInput) int
		UpdateEmbedder  func(childComplexity int, input *UpdateEmbedderInput) int
	}

	EmbedderQuery struct {
		GetEmbedder   func(childComplexity int, name string, namespace string) int
		ListEmbedders func(childComplexity int, input ListCommonInput) int
	}

	Endpoint struct {
		AuthSecret func(childComplexity int) int
		Insecure   func(childComplexity int) int
		URL        func(childComplexity int) int
	}

	F struct {
		Count             func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		FileType          func(childComplexity int) int
		Path              func(childComplexity int) int
		Size              func(childComplexity int) int
		Time              func(childComplexity int) int
	}

	KnowledgeBase struct {
		Annotations       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		Embedder          func(childComplexity int) int
		FileGroupDetails  func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Reason            func(childComplexity int) int
		Status            func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
		VectorStore       func(childComplexity int) int
	}

	KnowledgeBaseMutation struct {
		CreateKnowledgeBase func(childComplexity int, input CreateKnowledgeBaseInput) int
		DeleteKnowledgeBase func(childComplexity int, input *DeleteCommonInput) int
		UpdateKnowledgeBase func(childComplexity int, input *UpdateKnowledgeBaseInput) int
	}

	KnowledgeBaseQuery struct {
		GetKnowledgeBase   func(childComplexity int, name string, namespace string) int
		ListKnowledgeBases func(childComplexity int, input ListKnowledgeBaseInput) int
	}

	LLM struct {
		Annotations       func(childComplexity int) int
		BaseURL           func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		Models            func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Provider          func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	LLMConfig struct {
		MaxTokens      func(childComplexity int) int
		Model          func(childComplexity int) int
		Name           func(childComplexity int) int
		Namespace      func(childComplexity int) int
		PromptTemplate func(childComplexity int) int
		Provider       func(childComplexity int) int
		Temperature    func(childComplexity int) int
		TopP           func(childComplexity int) int
	}

	LLMQuery struct {
		GetLlm   func(childComplexity int, name string, namespace string) int
		ListLLMs func(childComplexity int, input ListCommonInput) int
	}

	Model struct {
		Annotations       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		Files             func(childComplexity int, input *FileFilter) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Status            func(childComplexity int) int
		SystemModel       func(childComplexity int) int
		Types             func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	ModelMutation struct {
		CreateModel  func(childComplexity int, input CreateModelInput) int
		DeleteModels func(childComplexity int, input *DeleteCommonInput) int
		UpdateModel  func(childComplexity int, input *UpdateModelInput) int
	}

	ModelQuery struct {
		GetModel   func(childComplexity int, name string, namespace string) int
		ListModels func(childComplexity int, input ListModelInput) int
	}

	ModelService struct {
		APIType           func(childComplexity int) int
		Annotations       func(childComplexity int) int
		BaseURL           func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		EmbeddingModels   func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		LlmModels         func(childComplexity int) int
		Message           func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		ProviderType      func(childComplexity int) int
		Status            func(childComplexity int) int
		Types             func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	ModelServiceMutation struct {
		CreateModelService func(childComplexity int, input CreateModelServiceInput) int
		DeleteModelService func(childComplexity int, input *DeleteCommonInput) int
		UpdateModelService func(childComplexity int, input *UpdateModelServiceInput) int
	}

	ModelServiceQuery struct {
		CheckModelService func(childComplexity int, input CreateModelServiceInput) int
		GetModelService   func(childComplexity int, name string, namespace string) int
		ListModelServices func(childComplexity int, input *ListModelServiceInput) int
	}

	Mutation struct {
		Application      func(childComplexity int) int
		DataProcess      func(childComplexity int) int
		Dataset          func(childComplexity int) int
		Datasource       func(childComplexity int) int
		Embedder         func(childComplexity int) int
		Hello            func(childComplexity int, name string) int
		KnowledgeBase    func(childComplexity int) int
		Model            func(childComplexity int) int
		ModelService     func(childComplexity int) int
		VersionedDataset func(childComplexity int) int
		Worker           func(childComplexity int) int
	}

	Oss struct {
		Bucket func(childComplexity int) int
		Object func(childComplexity int) int
	}

	PaginatedDataProcessItem struct {
		Data    func(childComplexity int) int
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	PaginatedResult struct {
		HasNextPage func(childComplexity int) int
		Nodes       func(childComplexity int) int
		Page        func(childComplexity int) int
		PageSize    func(childComplexity int) int
		TotalCount  func(childComplexity int) int
	}

	Query struct {
		Application      func(childComplexity int) int
		DataProcess      func(childComplexity int) int
		Dataset          func(childComplexity int) int
		Datasource       func(childComplexity int) int
		Embedder         func(childComplexity int) int
		Hello            func(childComplexity int, name string) int
		KnowledgeBase    func(childComplexity int) int
		Llm              func(childComplexity int) int
		Model            func(childComplexity int) int
		ModelService     func(childComplexity int) int
		VersionedDataset func(childComplexity int) int
		Worker           func(childComplexity int) int
	}

	Resources struct {
		CPU       func(childComplexity int) int
		Memory    func(childComplexity int) int
		NvidiaGpu func(childComplexity int) int
	}

	TypedObjectReference struct {
		APIGroup  func(childComplexity int) int
		Kind      func(childComplexity int) int
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
	}

	VersionedDataset struct {
		Annotations       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		DataProcessStatus func(childComplexity int) int
		Dataset           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		Files             func(childComplexity int, input *FileFilter) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Released          func(childComplexity int) int
		SyncStatus        func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
		Version           func(childComplexity int) int
	}

	VersionedDatasetMutation struct {
		CreateVersionedDataset  func(childComplexity int, input CreateVersionedDatasetInput) int
		DeleteVersionedDatasets func(childComplexity int, input DeleteVersionedDatasetInput) int
		UpdateVersionedDataset  func(childComplexity int, input UpdateVersionedDatasetInput) int
	}

	VersionedDatasetQuery struct {
		GetVersionedDataset   func(childComplexity int, name string, namespace string) int
		ListVersionedDatasets func(childComplexity int, input ListVersionedDatasetInput) int
	}

	Worker struct {
		API               func(childComplexity int) int
		Annotations       func(childComplexity int) int
		CreationTimestamp func(childComplexity int) int
		Creator           func(childComplexity int) int
		Description       func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Message           func(childComplexity int) int
		Model             func(childComplexity int) int
		ModelTypes        func(childComplexity int) int
		Name              func(childComplexity int) int
		Namespace         func(childComplexity int) int
		Replicas          func(childComplexity int) int
		Resources         func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdateTimestamp   func(childComplexity int) int
	}

	WorkerMutation struct {
		CreateWorker  func(childComplexity int, input CreateWorkerInput) int
		DeleteWorkers func(childComplexity int, input *DeleteCommonInput) int
		UpdateWorker  func(childComplexity int, input *UpdateWorkerInput) int
	}

	WorkerQuery struct {
		GetWorker   func(childComplexity int, name string, namespace string) int
		ListWorkers func(childComplexity int, input ListWorkerInput) int
	}

	Filedetail struct {
		Count           func(childComplexity int) int
		FileType        func(childComplexity int) int
		Path            func(childComplexity int) int
		Phase           func(childComplexity int) int
		Size            func(childComplexity int) int
		UpdateTimestamp func(childComplexity int) int
	}

	Filegroup struct {
		Path   func(childComplexity int) int
		Source func(childComplexity int) int
	}

	Filegroupdetail struct {
		Filedetails func(childComplexity int) int
		Source      func(childComplexity int) int
	}
}

type ApplicationMutationResolver interface {
	CreateApplication(ctx context.Context, obj *ApplicationMutation, input CreateApplicationMetadataInput) (*ApplicationMetadata, error)
	UpdateApplication(ctx context.Context, obj *ApplicationMutation, input UpdateApplicationMetadataInput) (*ApplicationMetadata, error)
	DeleteApplication(ctx context.Context, obj *ApplicationMutation, input DeleteCommonInput) (*string, error)
	UpdateApplicationConfig(ctx context.Context, obj *ApplicationMutation, input UpdateApplicationConfigInput) (*Application, error)
}
type ApplicationQueryResolver interface {
	GetApplication(ctx context.Context, obj *ApplicationQuery, name string, namespace string) (*Application, error)
	ListApplicationMetadata(ctx context.Context, obj *ApplicationQuery, input ListCommonInput) (*PaginatedResult, error)
}
type DataProcessMutationResolver interface {
	CreateDataProcessTask(ctx context.Context, obj *DataProcessMutation, input *AddDataProcessInput) (*DataProcessResponse, error)
	DeleteDataProcessTask(ctx context.Context, obj *DataProcessMutation, input *DeleteDataProcessInput) (*DataProcessResponse, error)
}
type DataProcessQueryResolver interface {
	AllDataProcessListByPage(ctx context.Context, obj *DataProcessQuery, input *AllDataProcessListByPageInput) (*PaginatedDataProcessItem, error)
	AllDataProcessListByCount(ctx context.Context, obj *DataProcessQuery, input *AllDataProcessListByCountInput) (*CountDataProcessItem, error)
	DataProcessSupportType(ctx context.Context, obj *DataProcessQuery) (*DataProcessSupportType, error)
	DataProcessDetails(ctx context.Context, obj *DataProcessQuery, input *DataProcessDetailsInput) (*DataProcessDetails, error)
	CheckDataProcessTaskName(ctx context.Context, obj *DataProcessQuery, input *CheckDataProcessTaskNameInput) (*DataProcessResponse, error)
}
type DatasetResolver interface {
	Versions(ctx context.Context, obj *Dataset, input ListVersionedDatasetInput) (*PaginatedResult, error)
}
type DatasetMutationResolver interface {
	CreateDataset(ctx context.Context, obj *DatasetMutation, input *CreateDatasetInput) (*Dataset, error)
	UpdateDataset(ctx context.Context, obj *DatasetMutation, input *UpdateDatasetInput) (*Dataset, error)
	DeleteDatasets(ctx context.Context, obj *DatasetMutation, input *DeleteCommonInput) (*string, error)
}
type DatasetQueryResolver interface {
	GetDataset(ctx context.Context, obj *DatasetQuery, name string, namespace string) (*Dataset, error)
	ListDatasets(ctx context.Context, obj *DatasetQuery, input *ListDatasetInput) (*PaginatedResult, error)
}
type DatasourceMutationResolver interface {
	CreateDatasource(ctx context.Context, obj *DatasourceMutation, input CreateDatasourceInput) (*Datasource, error)
	UpdateDatasource(ctx context.Context, obj *DatasourceMutation, input *UpdateDatasourceInput) (*Datasource, error)
	DeleteDatasources(ctx context.Context, obj *DatasourceMutation, input *DeleteCommonInput) (*string, error)
}
type DatasourceQueryResolver interface {
	GetDatasource(ctx context.Context, obj *DatasourceQuery, name string, namespace string) (*Datasource, error)
	CheckDatasource(ctx context.Context, obj *DatasourceQuery, input CreateDatasourceInput) (*Datasource, error)
	ListDatasources(ctx context.Context, obj *DatasourceQuery, input ListCommonInput) (*PaginatedResult, error)
}
type EmbedderMutationResolver interface {
	CreateEmbedder(ctx context.Context, obj *EmbedderMutation, input CreateEmbedderInput) (*Embedder, error)
	UpdateEmbedder(ctx context.Context, obj *EmbedderMutation, input *UpdateEmbedderInput) (*Embedder, error)
	DeleteEmbedders(ctx context.Context, obj *EmbedderMutation, input *DeleteCommonInput) (*string, error)
}
type EmbedderQueryResolver interface {
	GetEmbedder(ctx context.Context, obj *EmbedderQuery, name string, namespace string) (*Embedder, error)
	ListEmbedders(ctx context.Context, obj *EmbedderQuery, input ListCommonInput) (*PaginatedResult, error)
}
type KnowledgeBaseMutationResolver interface {
	CreateKnowledgeBase(ctx context.Context, obj *KnowledgeBaseMutation, input CreateKnowledgeBaseInput) (*KnowledgeBase, error)
	UpdateKnowledgeBase(ctx context.Context, obj *KnowledgeBaseMutation, input *UpdateKnowledgeBaseInput) (*KnowledgeBase, error)
	DeleteKnowledgeBase(ctx context.Context, obj *KnowledgeBaseMutation, input *DeleteCommonInput) (*string, error)
}
type KnowledgeBaseQueryResolver interface {
	GetKnowledgeBase(ctx context.Context, obj *KnowledgeBaseQuery, name string, namespace string) (*KnowledgeBase, error)
	ListKnowledgeBases(ctx context.Context, obj *KnowledgeBaseQuery, input ListKnowledgeBaseInput) (*PaginatedResult, error)
}
type LLMQueryResolver interface {
	GetLlm(ctx context.Context, obj *LLMQuery, name string, namespace string) (*Llm, error)
	ListLLMs(ctx context.Context, obj *LLMQuery, input ListCommonInput) (*PaginatedResult, error)
}
type ModelResolver interface {
	Files(ctx context.Context, obj *Model, input *FileFilter) (*PaginatedResult, error)
}
type ModelMutationResolver interface {
	CreateModel(ctx context.Context, obj *ModelMutation, input CreateModelInput) (*Model, error)
	UpdateModel(ctx context.Context, obj *ModelMutation, input *UpdateModelInput) (*Model, error)
	DeleteModels(ctx context.Context, obj *ModelMutation, input *DeleteCommonInput) (*string, error)
}
type ModelQueryResolver interface {
	GetModel(ctx context.Context, obj *ModelQuery, name string, namespace string) (*Model, error)
	ListModels(ctx context.Context, obj *ModelQuery, input ListModelInput) (*PaginatedResult, error)
}
type ModelServiceMutationResolver interface {
	CreateModelService(ctx context.Context, obj *ModelServiceMutation, input CreateModelServiceInput) (*ModelService, error)
	UpdateModelService(ctx context.Context, obj *ModelServiceMutation, input *UpdateModelServiceInput) (*ModelService, error)
	DeleteModelService(ctx context.Context, obj *ModelServiceMutation, input *DeleteCommonInput) (*string, error)
}
type ModelServiceQueryResolver interface {
	GetModelService(ctx context.Context, obj *ModelServiceQuery, name string, namespace string) (*ModelService, error)
	ListModelServices(ctx context.Context, obj *ModelServiceQuery, input *ListModelServiceInput) (*PaginatedResult, error)
	CheckModelService(ctx context.Context, obj *ModelServiceQuery, input CreateModelServiceInput) (*ModelService, error)
}
type MutationResolver interface {
	Hello(ctx context.Context, name string) (string, error)
	Application(ctx context.Context) (*ApplicationMutation, error)
	DataProcess(ctx context.Context) (*DataProcessMutation, error)
	Dataset(ctx context.Context) (*DatasetMutation, error)
	Datasource(ctx context.Context) (*DatasourceMutation, error)
	Embedder(ctx context.Context) (*EmbedderMutation, error)
	KnowledgeBase(ctx context.Context) (*KnowledgeBaseMutation, error)
	Model(ctx context.Context) (*ModelMutation, error)
	ModelService(ctx context.Context) (*ModelServiceMutation, error)
	VersionedDataset(ctx context.Context) (*VersionedDatasetMutation, error)
	Worker(ctx context.Context) (*WorkerMutation, error)
}
type QueryResolver interface {
	Hello(ctx context.Context, name string) (string, error)
	Application(ctx context.Context) (*ApplicationQuery, error)
	DataProcess(ctx context.Context) (*DataProcessQuery, error)
	Dataset(ctx context.Context) (*DatasetQuery, error)
	Datasource(ctx context.Context) (*DatasourceQuery, error)
	Embedder(ctx context.Context) (*EmbedderQuery, error)
	KnowledgeBase(ctx context.Context) (*KnowledgeBaseQuery, error)
	Llm(ctx context.Context) (*LLMQuery, error)
	Model(ctx context.Context) (*ModelQuery, error)
	ModelService(ctx context.Context) (*ModelServiceQuery, error)
	VersionedDataset(ctx context.Context) (*VersionedDatasetQuery, error)
	Worker(ctx context.Context) (*WorkerQuery, error)
}
type VersionedDatasetResolver interface {
	Files(ctx context.Context, obj *VersionedDataset, input *FileFilter) (*PaginatedResult, error)
}
type VersionedDatasetMutationResolver interface {
	CreateVersionedDataset(ctx context.Context, obj *VersionedDatasetMutation, input CreateVersionedDatasetInput) (*VersionedDataset, error)
	UpdateVersionedDataset(ctx context.Context, obj *VersionedDatasetMutation, input UpdateVersionedDatasetInput) (*VersionedDataset, error)
	DeleteVersionedDatasets(ctx context.Context, obj *VersionedDatasetMutation, input DeleteVersionedDatasetInput) (*string, error)
}
type VersionedDatasetQueryResolver interface {
	GetVersionedDataset(ctx context.Context, obj *VersionedDatasetQuery, name string, namespace string) (*VersionedDataset, error)
	ListVersionedDatasets(ctx context.Context, obj *VersionedDatasetQuery, input ListVersionedDatasetInput) (*PaginatedResult, error)
}
type WorkerMutationResolver interface {
	CreateWorker(ctx context.Context, obj *WorkerMutation, input CreateWorkerInput) (*Worker, error)
	UpdateWorker(ctx context.Context, obj *WorkerMutation, input *UpdateWorkerInput) (*Worker, error)
	DeleteWorkers(ctx context.Context, obj *WorkerMutation, input *DeleteCommonInput) (*string, error)
}
type WorkerQueryResolver interface {
	GetWorker(ctx context.Context, obj *WorkerQuery, name string, namespace string) (*Worker, error)
	ListWorkers(ctx context.Context, obj *WorkerQuery, input ListWorkerInput) (*PaginatedResult, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Application.conversionWindowSize":
		if e.complexity.Application.ConversionWindowSize == nil {
			break
		}

		return e.complexity.Application.ConversionWindowSize(childComplexity), true

	case "Application.docNullReturn":
		if e.complexity.Application.DocNullReturn == nil {
			break
		}

		return e.complexity.Application.DocNullReturn(childComplexity), true

	case "Application.knowledgebase":
		if e.complexity.Application.Knowledgebase == nil {
			break
		}

		return e.complexity.Application.Knowledgebase(childComplexity), true

	case "Application.llm":
		if e.complexity.Application.Llm == nil {
			break
		}

		return e.complexity.Application.Llm(childComplexity), true

	case "Application.maxLength":
		if e.complexity.Application.MaxLength == nil {
			break
		}

		return e.complexity.Application.MaxLength(childComplexity), true

	case "Application.metadata":
		if e.complexity.Application.Metadata == nil {
			break
		}

		return e.complexity.Application.Metadata(childComplexity), true

	case "Application.model":
		if e.complexity.Application.Model == nil {
			break
		}

		return e.complexity.Application.Model(childComplexity), true

	case "Application.numDocuments":
		if e.complexity.Application.NumDocuments == nil {
			break
		}

		return e.complexity.Application.NumDocuments(childComplexity), true

	case "Application.prologue":
		if e.complexity.Application.Prologue == nil {
			break
		}

		return e.complexity.Application.Prologue(childComplexity), true

	case "Application.scoreThreshold":
		if e.complexity.Application.ScoreThreshold == nil {
			break
		}

		return e.complexity.Application.ScoreThreshold(childComplexity), true

	case "Application.showNextGuid":
		if e.complexity.Application.ShowNextGUID == nil {
			break
		}

		return e.complexity.Application.ShowNextGUID(childComplexity), true

	case "Application.temperature":
		if e.complexity.Application.Temperature == nil {
			break
		}

		return e.complexity.Application.Temperature(childComplexity), true

	case "Application.userPrompt":
		if e.complexity.Application.UserPrompt == nil {
			break
		}

		return e.complexity.Application.UserPrompt(childComplexity), true

	case "ApplicationMetadata.annotations":
		if e.complexity.ApplicationMetadata.Annotations == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Annotations(childComplexity), true

	case "ApplicationMetadata.creationTimestamp":
		if e.complexity.ApplicationMetadata.CreationTimestamp == nil {
			break
		}

		return e.complexity.ApplicationMetadata.CreationTimestamp(childComplexity), true

	case "ApplicationMetadata.creator":
		if e.complexity.ApplicationMetadata.Creator == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Creator(childComplexity), true

	case "ApplicationMetadata.description":
		if e.complexity.ApplicationMetadata.Description == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Description(childComplexity), true

	case "ApplicationMetadata.displayName":
		if e.complexity.ApplicationMetadata.DisplayName == nil {
			break
		}

		return e.complexity.ApplicationMetadata.DisplayName(childComplexity), true

	case "ApplicationMetadata.id":
		if e.complexity.ApplicationMetadata.ID == nil {
			break
		}

		return e.complexity.ApplicationMetadata.ID(childComplexity), true

	case "ApplicationMetadata.icon":
		if e.complexity.ApplicationMetadata.Icon == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Icon(childComplexity), true

	case "ApplicationMetadata.isPublic":
		if e.complexity.ApplicationMetadata.IsPublic == nil {
			break
		}

		return e.complexity.ApplicationMetadata.IsPublic(childComplexity), true

	case "ApplicationMetadata.labels":
		if e.complexity.ApplicationMetadata.Labels == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Labels(childComplexity), true

	case "ApplicationMetadata.name":
		if e.complexity.ApplicationMetadata.Name == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Name(childComplexity), true

	case "ApplicationMetadata.namespace":
		if e.complexity.ApplicationMetadata.Namespace == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Namespace(childComplexity), true

	case "ApplicationMetadata.status":
		if e.complexity.ApplicationMetadata.Status == nil {
			break
		}

		return e.complexity.ApplicationMetadata.Status(childComplexity), true

	case "ApplicationMetadata.updateTimestamp":
		if e.complexity.ApplicationMetadata.UpdateTimestamp == nil {
			break
		}

		return e.complexity.ApplicationMetadata.UpdateTimestamp(childComplexity), true

	case "ApplicationMutation.createApplication":
		if e.complexity.ApplicationMutation.CreateApplication == nil {
			break
		}

		args, err := ec.field_ApplicationMutation_createApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationMutation.CreateApplication(childComplexity, args["input"].(CreateApplicationMetadataInput)), true

	case "ApplicationMutation.deleteApplication":
		if e.complexity.ApplicationMutation.DeleteApplication == nil {
			break
		}

		args, err := ec.field_ApplicationMutation_deleteApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationMutation.DeleteApplication(childComplexity, args["input"].(DeleteCommonInput)), true

	case "ApplicationMutation.updateApplication":
		if e.complexity.ApplicationMutation.UpdateApplication == nil {
			break
		}

		args, err := ec.field_ApplicationMutation_updateApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationMutation.UpdateApplication(childComplexity, args["input"].(UpdateApplicationMetadataInput)), true

	case "ApplicationMutation.updateApplicationConfig":
		if e.complexity.ApplicationMutation.UpdateApplicationConfig == nil {
			break
		}

		args, err := ec.field_ApplicationMutation_updateApplicationConfig_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationMutation.UpdateApplicationConfig(childComplexity, args["input"].(UpdateApplicationConfigInput)), true

	case "ApplicationQuery.getApplication":
		if e.complexity.ApplicationQuery.GetApplication == nil {
			break
		}

		args, err := ec.field_ApplicationQuery_getApplication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationQuery.GetApplication(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "ApplicationQuery.listApplicationMetadata":
		if e.complexity.ApplicationQuery.ListApplicationMetadata == nil {
			break
		}

		args, err := ec.field_ApplicationQuery_listApplicationMetadata_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ApplicationQuery.ListApplicationMetadata(childComplexity, args["input"].(ListCommonInput)), true

	case "CountDataProcessItem.data":
		if e.complexity.CountDataProcessItem.Data == nil {
			break
		}

		return e.complexity.CountDataProcessItem.Data(childComplexity), true

	case "CountDataProcessItem.message":
		if e.complexity.CountDataProcessItem.Message == nil {
			break
		}

		return e.complexity.CountDataProcessItem.Message(childComplexity), true

	case "CountDataProcessItem.status":
		if e.complexity.CountDataProcessItem.Status == nil {
			break
		}

		return e.complexity.CountDataProcessItem.Status(childComplexity), true

	case "DataProcessConfig.children":
		if e.complexity.DataProcessConfig.Children == nil {
			break
		}

		return e.complexity.DataProcessConfig.Children(childComplexity), true

	case "DataProcessConfig.description":
		if e.complexity.DataProcessConfig.Description == nil {
			break
		}

		return e.complexity.DataProcessConfig.Description(childComplexity), true

	case "DataProcessConfig.file_num":
		if e.complexity.DataProcessConfig.FileNum == nil {
			break
		}

		return e.complexity.DataProcessConfig.FileNum(childComplexity), true

	case "DataProcessConfig.name":
		if e.complexity.DataProcessConfig.Name == nil {
			break
		}

		return e.complexity.DataProcessConfig.Name(childComplexity), true

	case "DataProcessConfig.status":
		if e.complexity.DataProcessConfig.Status == nil {
			break
		}

		return e.complexity.DataProcessConfig.Status(childComplexity), true

	case "DataProcessConfigChildren.description":
		if e.complexity.DataProcessConfigChildren.Description == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.Description(childComplexity), true

	case "DataProcessConfigChildren.enable":
		if e.complexity.DataProcessConfigChildren.Enable == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.Enable(childComplexity), true

	case "DataProcessConfigChildren.file_progress":
		if e.complexity.DataProcessConfigChildren.FileProgress == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.FileProgress(childComplexity), true

	case "DataProcessConfigChildren.llm_config":
		if e.complexity.DataProcessConfigChildren.LlmConfig == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.LlmConfig(childComplexity), true

	case "DataProcessConfigChildren.name":
		if e.complexity.DataProcessConfigChildren.Name == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.Name(childComplexity), true

	case "DataProcessConfigChildren.preview":
		if e.complexity.DataProcessConfigChildren.Preview == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.Preview(childComplexity), true

	case "DataProcessConfigChildren.zh_name":
		if e.complexity.DataProcessConfigChildren.ZhName == nil {
			break
		}

		return e.complexity.DataProcessConfigChildren.ZhName(childComplexity), true

	case "DataProcessConfigpreFileProgress.end_time":
		if e.complexity.DataProcessConfigpreFileProgress.EndTime == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.EndTime(childComplexity), true

	case "DataProcessConfigpreFileProgress.file_name":
		if e.complexity.DataProcessConfigpreFileProgress.FileName == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.FileName(childComplexity), true

	case "DataProcessConfigpreFileProgress.id":
		if e.complexity.DataProcessConfigpreFileProgress.ID == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.ID(childComplexity), true

	case "DataProcessConfigpreFileProgress.progress":
		if e.complexity.DataProcessConfigpreFileProgress.Progress == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.Progress(childComplexity), true

	case "DataProcessConfigpreFileProgress.start_time":
		if e.complexity.DataProcessConfigpreFileProgress.StartTime == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.StartTime(childComplexity), true

	case "DataProcessConfigpreFileProgress.status":
		if e.complexity.DataProcessConfigpreFileProgress.Status == nil {
			break
		}

		return e.complexity.DataProcessConfigpreFileProgress.Status(childComplexity), true

	case "DataProcessConfigpreView.content":
		if e.complexity.DataProcessConfigpreView.Content == nil {
			break
		}

		return e.complexity.DataProcessConfigpreView.Content(childComplexity), true

	case "DataProcessConfigpreView.file_name":
		if e.complexity.DataProcessConfigpreView.FileName == nil {
			break
		}

		return e.complexity.DataProcessConfigpreView.FileName(childComplexity), true

	case "DataProcessConfigpreViewContent.post":
		if e.complexity.DataProcessConfigpreViewContent.Post == nil {
			break
		}

		return e.complexity.DataProcessConfigpreViewContent.Post(childComplexity), true

	case "DataProcessConfigpreViewContent.pre":
		if e.complexity.DataProcessConfigpreViewContent.Pre == nil {
			break
		}

		return e.complexity.DataProcessConfigpreViewContent.Pre(childComplexity), true

	case "DataProcessDetails.data":
		if e.complexity.DataProcessDetails.Data == nil {
			break
		}

		return e.complexity.DataProcessDetails.Data(childComplexity), true

	case "DataProcessDetails.message":
		if e.complexity.DataProcessDetails.Message == nil {
			break
		}

		return e.complexity.DataProcessDetails.Message(childComplexity), true

	case "DataProcessDetails.status":
		if e.complexity.DataProcessDetails.Status == nil {
			break
		}

		return e.complexity.DataProcessDetails.Status(childComplexity), true

	case "DataProcessDetailsItem.config":
		if e.complexity.DataProcessDetailsItem.Config == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.Config(childComplexity), true

	case "DataProcessDetailsItem.creator":
		if e.complexity.DataProcessDetailsItem.Creator == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.Creator(childComplexity), true

	case "DataProcessDetailsItem.end_time":
		if e.complexity.DataProcessDetailsItem.EndTime == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.EndTime(childComplexity), true

	case "DataProcessDetailsItem.error_msg":
		if e.complexity.DataProcessDetailsItem.ErrorMsg == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.ErrorMsg(childComplexity), true

	case "DataProcessDetailsItem.file_num":
		if e.complexity.DataProcessDetailsItem.FileNum == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.FileNum(childComplexity), true

	case "DataProcessDetailsItem.file_type":
		if e.complexity.DataProcessDetailsItem.FileType == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.FileType(childComplexity), true

	case "DataProcessDetailsItem.id":
		if e.complexity.DataProcessDetailsItem.ID == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.ID(childComplexity), true

	case "DataProcessDetailsItem.name":
		if e.complexity.DataProcessDetailsItem.Name == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.Name(childComplexity), true

	case "DataProcessDetailsItem.post_dataset_name":
		if e.complexity.DataProcessDetailsItem.PostDatasetName == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.PostDatasetName(childComplexity), true

	case "DataProcessDetailsItem.post_dataset_version":
		if e.complexity.DataProcessDetailsItem.PostDatasetVersion == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.PostDatasetVersion(childComplexity), true

	case "DataProcessDetailsItem.pre_dataset_name":
		if e.complexity.DataProcessDetailsItem.PreDatasetName == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.PreDatasetName(childComplexity), true

	case "DataProcessDetailsItem.pre_dataset_version":
		if e.complexity.DataProcessDetailsItem.PreDatasetVersion == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.PreDatasetVersion(childComplexity), true

	case "DataProcessDetailsItem.start_time":
		if e.complexity.DataProcessDetailsItem.StartTime == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.StartTime(childComplexity), true

	case "DataProcessDetailsItem.status":
		if e.complexity.DataProcessDetailsItem.Status == nil {
			break
		}

		return e.complexity.DataProcessDetailsItem.Status(childComplexity), true

	case "DataProcessItem.error_msg":
		if e.complexity.DataProcessItem.ErrorMsg == nil {
			break
		}

		return e.complexity.DataProcessItem.ErrorMsg(childComplexity), true

	case "DataProcessItem.id":
		if e.complexity.DataProcessItem.ID == nil {
			break
		}

		return e.complexity.DataProcessItem.ID(childComplexity), true

	case "DataProcessItem.name":
		if e.complexity.DataProcessItem.Name == nil {
			break
		}

		return e.complexity.DataProcessItem.Name(childComplexity), true

	case "DataProcessItem.post_data_set_name":
		if e.complexity.DataProcessItem.PostDataSetName == nil {
			break
		}

		return e.complexity.DataProcessItem.PostDataSetName(childComplexity), true

	case "DataProcessItem.post_data_set_version":
		if e.complexity.DataProcessItem.PostDataSetVersion == nil {
			break
		}

		return e.complexity.DataProcessItem.PostDataSetVersion(childComplexity), true

	case "DataProcessItem.pre_data_set_name":
		if e.complexity.DataProcessItem.PreDataSetName == nil {
			break
		}

		return e.complexity.DataProcessItem.PreDataSetName(childComplexity), true

	case "DataProcessItem.pre_data_set_version":
		if e.complexity.DataProcessItem.PreDataSetVersion == nil {
			break
		}

		return e.complexity.DataProcessItem.PreDataSetVersion(childComplexity), true

	case "DataProcessItem.start_datetime":
		if e.complexity.DataProcessItem.StartDatetime == nil {
			break
		}

		return e.complexity.DataProcessItem.StartDatetime(childComplexity), true

	case "DataProcessItem.status":
		if e.complexity.DataProcessItem.Status == nil {
			break
		}

		return e.complexity.DataProcessItem.Status(childComplexity), true

	case "DataProcessMutation.createDataProcessTask":
		if e.complexity.DataProcessMutation.CreateDataProcessTask == nil {
			break
		}

		args, err := ec.field_DataProcessMutation_createDataProcessTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessMutation.CreateDataProcessTask(childComplexity, args["input"].(*AddDataProcessInput)), true

	case "DataProcessMutation.deleteDataProcessTask":
		if e.complexity.DataProcessMutation.DeleteDataProcessTask == nil {
			break
		}

		args, err := ec.field_DataProcessMutation_deleteDataProcessTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessMutation.DeleteDataProcessTask(childComplexity, args["input"].(*DeleteDataProcessInput)), true

	case "DataProcessQuery.allDataProcessListByCount":
		if e.complexity.DataProcessQuery.AllDataProcessListByCount == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_allDataProcessListByCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.AllDataProcessListByCount(childComplexity, args["input"].(*AllDataProcessListByCountInput)), true

	case "DataProcessQuery.allDataProcessListByPage":
		if e.complexity.DataProcessQuery.AllDataProcessListByPage == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_allDataProcessListByPage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.AllDataProcessListByPage(childComplexity, args["input"].(*AllDataProcessListByPageInput)), true

	case "DataProcessQuery.checkDataProcessTaskName":
		if e.complexity.DataProcessQuery.CheckDataProcessTaskName == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_checkDataProcessTaskName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.CheckDataProcessTaskName(childComplexity, args["input"].(*CheckDataProcessTaskNameInput)), true

	case "DataProcessQuery.dataProcessDetails":
		if e.complexity.DataProcessQuery.DataProcessDetails == nil {
			break
		}

		args, err := ec.field_DataProcessQuery_dataProcessDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DataProcessQuery.DataProcessDetails(childComplexity, args["input"].(*DataProcessDetailsInput)), true

	case "DataProcessQuery.dataProcessSupportType":
		if e.complexity.DataProcessQuery.DataProcessSupportType == nil {
			break
		}

		return e.complexity.DataProcessQuery.DataProcessSupportType(childComplexity), true

	case "DataProcessResponse.data":
		if e.complexity.DataProcessResponse.Data == nil {
			break
		}

		return e.complexity.DataProcessResponse.Data(childComplexity), true

	case "DataProcessResponse.message":
		if e.complexity.DataProcessResponse.Message == nil {
			break
		}

		return e.complexity.DataProcessResponse.Message(childComplexity), true

	case "DataProcessResponse.status":
		if e.complexity.DataProcessResponse.Status == nil {
			break
		}

		return e.complexity.DataProcessResponse.Status(childComplexity), true

	case "DataProcessSupportType.data":
		if e.complexity.DataProcessSupportType.Data == nil {
			break
		}

		return e.complexity.DataProcessSupportType.Data(childComplexity), true

	case "DataProcessSupportType.message":
		if e.complexity.DataProcessSupportType.Message == nil {
			break
		}

		return e.complexity.DataProcessSupportType.Message(childComplexity), true

	case "DataProcessSupportType.status":
		if e.complexity.DataProcessSupportType.Status == nil {
			break
		}

		return e.complexity.DataProcessSupportType.Status(childComplexity), true

	case "DataProcessSupportTypeChildren.description":
		if e.complexity.DataProcessSupportTypeChildren.Description == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeChildren.Description(childComplexity), true

	case "DataProcessSupportTypeChildren.enable":
		if e.complexity.DataProcessSupportTypeChildren.Enable == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeChildren.Enable(childComplexity), true

	case "DataProcessSupportTypeChildren.name":
		if e.complexity.DataProcessSupportTypeChildren.Name == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeChildren.Name(childComplexity), true

	case "DataProcessSupportTypeChildren.zh_name":
		if e.complexity.DataProcessSupportTypeChildren.ZhName == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeChildren.ZhName(childComplexity), true

	case "DataProcessSupportTypeItem.children":
		if e.complexity.DataProcessSupportTypeItem.Children == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeItem.Children(childComplexity), true

	case "DataProcessSupportTypeItem.description":
		if e.complexity.DataProcessSupportTypeItem.Description == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeItem.Description(childComplexity), true

	case "DataProcessSupportTypeItem.name":
		if e.complexity.DataProcessSupportTypeItem.Name == nil {
			break
		}

		return e.complexity.DataProcessSupportTypeItem.Name(childComplexity), true

	case "Dataset.annotations":
		if e.complexity.Dataset.Annotations == nil {
			break
		}

		return e.complexity.Dataset.Annotations(childComplexity), true

	case "Dataset.contentType":
		if e.complexity.Dataset.ContentType == nil {
			break
		}

		return e.complexity.Dataset.ContentType(childComplexity), true

	case "Dataset.creationTimestamp":
		if e.complexity.Dataset.CreationTimestamp == nil {
			break
		}

		return e.complexity.Dataset.CreationTimestamp(childComplexity), true

	case "Dataset.creator":
		if e.complexity.Dataset.Creator == nil {
			break
		}

		return e.complexity.Dataset.Creator(childComplexity), true

	case "Dataset.description":
		if e.complexity.Dataset.Description == nil {
			break
		}

		return e.complexity.Dataset.Description(childComplexity), true

	case "Dataset.displayName":
		if e.complexity.Dataset.DisplayName == nil {
			break
		}

		return e.complexity.Dataset.DisplayName(childComplexity), true

	case "Dataset.field":
		if e.complexity.Dataset.Field == nil {
			break
		}

		return e.complexity.Dataset.Field(childComplexity), true

	case "Dataset.labels":
		if e.complexity.Dataset.Labels == nil {
			break
		}

		return e.complexity.Dataset.Labels(childComplexity), true

	case "Dataset.name":
		if e.complexity.Dataset.Name == nil {
			break
		}

		return e.complexity.Dataset.Name(childComplexity), true

	case "Dataset.namespace":
		if e.complexity.Dataset.Namespace == nil {
			break
		}

		return e.complexity.Dataset.Namespace(childComplexity), true

	case "Dataset.updateTimestamp":
		if e.complexity.Dataset.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Dataset.UpdateTimestamp(childComplexity), true

	case "Dataset.versions":
		if e.complexity.Dataset.Versions == nil {
			break
		}

		args, err := ec.field_Dataset_versions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Dataset.Versions(childComplexity, args["input"].(ListVersionedDatasetInput)), true

	case "DatasetMutation.createDataset":
		if e.complexity.DatasetMutation.CreateDataset == nil {
			break
		}

		args, err := ec.field_DatasetMutation_createDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetMutation.CreateDataset(childComplexity, args["input"].(*CreateDatasetInput)), true

	case "DatasetMutation.deleteDatasets":
		if e.complexity.DatasetMutation.DeleteDatasets == nil {
			break
		}

		args, err := ec.field_DatasetMutation_deleteDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetMutation.DeleteDatasets(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "DatasetMutation.updateDataset":
		if e.complexity.DatasetMutation.UpdateDataset == nil {
			break
		}

		args, err := ec.field_DatasetMutation_updateDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetMutation.UpdateDataset(childComplexity, args["input"].(*UpdateDatasetInput)), true

	case "DatasetQuery.getDataset":
		if e.complexity.DatasetQuery.GetDataset == nil {
			break
		}

		args, err := ec.field_DatasetQuery_getDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetQuery.GetDataset(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "DatasetQuery.listDatasets":
		if e.complexity.DatasetQuery.ListDatasets == nil {
			break
		}

		args, err := ec.field_DatasetQuery_listDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetQuery.ListDatasets(childComplexity, args["input"].(*ListDatasetInput)), true

	case "Datasource.annotations":
		if e.complexity.Datasource.Annotations == nil {
			break
		}

		return e.complexity.Datasource.Annotations(childComplexity), true

	case "Datasource.creationTimestamp":
		if e.complexity.Datasource.CreationTimestamp == nil {
			break
		}

		return e.complexity.Datasource.CreationTimestamp(childComplexity), true

	case "Datasource.creator":
		if e.complexity.Datasource.Creator == nil {
			break
		}

		return e.complexity.Datasource.Creator(childComplexity), true

	case "Datasource.description":
		if e.complexity.Datasource.Description == nil {
			break
		}

		return e.complexity.Datasource.Description(childComplexity), true

	case "Datasource.displayName":
		if e.complexity.Datasource.DisplayName == nil {
			break
		}

		return e.complexity.Datasource.DisplayName(childComplexity), true

	case "Datasource.endpoint":
		if e.complexity.Datasource.Endpoint == nil {
			break
		}

		return e.complexity.Datasource.Endpoint(childComplexity), true

	case "Datasource.id":
		if e.complexity.Datasource.ID == nil {
			break
		}

		return e.complexity.Datasource.ID(childComplexity), true

	case "Datasource.labels":
		if e.complexity.Datasource.Labels == nil {
			break
		}

		return e.complexity.Datasource.Labels(childComplexity), true

	case "Datasource.message":
		if e.complexity.Datasource.Message == nil {
			break
		}

		return e.complexity.Datasource.Message(childComplexity), true

	case "Datasource.name":
		if e.complexity.Datasource.Name == nil {
			break
		}

		return e.complexity.Datasource.Name(childComplexity), true

	case "Datasource.namespace":
		if e.complexity.Datasource.Namespace == nil {
			break
		}

		return e.complexity.Datasource.Namespace(childComplexity), true

	case "Datasource.oss":
		if e.complexity.Datasource.Oss == nil {
			break
		}

		return e.complexity.Datasource.Oss(childComplexity), true

	case "Datasource.status":
		if e.complexity.Datasource.Status == nil {
			break
		}

		return e.complexity.Datasource.Status(childComplexity), true

	case "Datasource.updateTimestamp":
		if e.complexity.Datasource.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Datasource.UpdateTimestamp(childComplexity), true

	case "DatasourceMutation.createDatasource":
		if e.complexity.DatasourceMutation.CreateDatasource == nil {
			break
		}

		args, err := ec.field_DatasourceMutation_createDatasource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceMutation.CreateDatasource(childComplexity, args["input"].(CreateDatasourceInput)), true

	case "DatasourceMutation.deleteDatasources":
		if e.complexity.DatasourceMutation.DeleteDatasources == nil {
			break
		}

		args, err := ec.field_DatasourceMutation_deleteDatasources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceMutation.DeleteDatasources(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "DatasourceMutation.updateDatasource":
		if e.complexity.DatasourceMutation.UpdateDatasource == nil {
			break
		}

		args, err := ec.field_DatasourceMutation_updateDatasource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceMutation.UpdateDatasource(childComplexity, args["input"].(*UpdateDatasourceInput)), true

	case "DatasourceQuery.checkDatasource":
		if e.complexity.DatasourceQuery.CheckDatasource == nil {
			break
		}

		args, err := ec.field_DatasourceQuery_checkDatasource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceQuery.CheckDatasource(childComplexity, args["input"].(CreateDatasourceInput)), true

	case "DatasourceQuery.getDatasource":
		if e.complexity.DatasourceQuery.GetDatasource == nil {
			break
		}

		args, err := ec.field_DatasourceQuery_getDatasource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceQuery.GetDatasource(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "DatasourceQuery.listDatasources":
		if e.complexity.DatasourceQuery.ListDatasources == nil {
			break
		}

		args, err := ec.field_DatasourceQuery_listDatasources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasourceQuery.ListDatasources(childComplexity, args["input"].(ListCommonInput)), true

	case "Embedder.annotations":
		if e.complexity.Embedder.Annotations == nil {
			break
		}

		return e.complexity.Embedder.Annotations(childComplexity), true

	case "Embedder.baseUrl":
		if e.complexity.Embedder.BaseURL == nil {
			break
		}

		return e.complexity.Embedder.BaseURL(childComplexity), true

	case "Embedder.creationTimestamp":
		if e.complexity.Embedder.CreationTimestamp == nil {
			break
		}

		return e.complexity.Embedder.CreationTimestamp(childComplexity), true

	case "Embedder.creator":
		if e.complexity.Embedder.Creator == nil {
			break
		}

		return e.complexity.Embedder.Creator(childComplexity), true

	case "Embedder.description":
		if e.complexity.Embedder.Description == nil {
			break
		}

		return e.complexity.Embedder.Description(childComplexity), true

	case "Embedder.displayName":
		if e.complexity.Embedder.DisplayName == nil {
			break
		}

		return e.complexity.Embedder.DisplayName(childComplexity), true

	case "Embedder.id":
		if e.complexity.Embedder.ID == nil {
			break
		}

		return e.complexity.Embedder.ID(childComplexity), true

	case "Embedder.labels":
		if e.complexity.Embedder.Labels == nil {
			break
		}

		return e.complexity.Embedder.Labels(childComplexity), true

	case "Embedder.message":
		if e.complexity.Embedder.Message == nil {
			break
		}

		return e.complexity.Embedder.Message(childComplexity), true

	case "Embedder.models":
		if e.complexity.Embedder.Models == nil {
			break
		}

		return e.complexity.Embedder.Models(childComplexity), true

	case "Embedder.name":
		if e.complexity.Embedder.Name == nil {
			break
		}

		return e.complexity.Embedder.Name(childComplexity), true

	case "Embedder.namespace":
		if e.complexity.Embedder.Namespace == nil {
			break
		}

		return e.complexity.Embedder.Namespace(childComplexity), true

	case "Embedder.provider":
		if e.complexity.Embedder.Provider == nil {
			break
		}

		return e.complexity.Embedder.Provider(childComplexity), true

	case "Embedder.status":
		if e.complexity.Embedder.Status == nil {
			break
		}

		return e.complexity.Embedder.Status(childComplexity), true

	case "Embedder.type":
		if e.complexity.Embedder.Type == nil {
			break
		}

		return e.complexity.Embedder.Type(childComplexity), true

	case "Embedder.updateTimestamp":
		if e.complexity.Embedder.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Embedder.UpdateTimestamp(childComplexity), true

	case "EmbedderMutation.createEmbedder":
		if e.complexity.EmbedderMutation.CreateEmbedder == nil {
			break
		}

		args, err := ec.field_EmbedderMutation_createEmbedder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.EmbedderMutation.CreateEmbedder(childComplexity, args["input"].(CreateEmbedderInput)), true

	case "EmbedderMutation.deleteEmbedders":
		if e.complexity.EmbedderMutation.DeleteEmbedders == nil {
			break
		}

		args, err := ec.field_EmbedderMutation_deleteEmbedders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.EmbedderMutation.DeleteEmbedders(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "EmbedderMutation.updateEmbedder":
		if e.complexity.EmbedderMutation.UpdateEmbedder == nil {
			break
		}

		args, err := ec.field_EmbedderMutation_updateEmbedder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.EmbedderMutation.UpdateEmbedder(childComplexity, args["input"].(*UpdateEmbedderInput)), true

	case "EmbedderQuery.getEmbedder":
		if e.complexity.EmbedderQuery.GetEmbedder == nil {
			break
		}

		args, err := ec.field_EmbedderQuery_getEmbedder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.EmbedderQuery.GetEmbedder(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "EmbedderQuery.listEmbedders":
		if e.complexity.EmbedderQuery.ListEmbedders == nil {
			break
		}

		args, err := ec.field_EmbedderQuery_listEmbedders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.EmbedderQuery.ListEmbedders(childComplexity, args["input"].(ListCommonInput)), true

	case "Endpoint.authSecret":
		if e.complexity.Endpoint.AuthSecret == nil {
			break
		}

		return e.complexity.Endpoint.AuthSecret(childComplexity), true

	case "Endpoint.insecure":
		if e.complexity.Endpoint.Insecure == nil {
			break
		}

		return e.complexity.Endpoint.Insecure(childComplexity), true

	case "Endpoint.url":
		if e.complexity.Endpoint.URL == nil {
			break
		}

		return e.complexity.Endpoint.URL(childComplexity), true

	case "F.count":
		if e.complexity.F.Count == nil {
			break
		}

		return e.complexity.F.Count(childComplexity), true

	case "F.creationTimestamp":
		if e.complexity.F.CreationTimestamp == nil {
			break
		}

		return e.complexity.F.CreationTimestamp(childComplexity), true

	case "F.fileType":
		if e.complexity.F.FileType == nil {
			break
		}

		return e.complexity.F.FileType(childComplexity), true

	case "F.path":
		if e.complexity.F.Path == nil {
			break
		}

		return e.complexity.F.Path(childComplexity), true

	case "F.size":
		if e.complexity.F.Size == nil {
			break
		}

		return e.complexity.F.Size(childComplexity), true

	case "F.time":
		if e.complexity.F.Time == nil {
			break
		}

		return e.complexity.F.Time(childComplexity), true

	case "KnowledgeBase.annotations":
		if e.complexity.KnowledgeBase.Annotations == nil {
			break
		}

		return e.complexity.KnowledgeBase.Annotations(childComplexity), true

	case "KnowledgeBase.creationTimestamp":
		if e.complexity.KnowledgeBase.CreationTimestamp == nil {
			break
		}

		return e.complexity.KnowledgeBase.CreationTimestamp(childComplexity), true

	case "KnowledgeBase.creator":
		if e.complexity.KnowledgeBase.Creator == nil {
			break
		}

		return e.complexity.KnowledgeBase.Creator(childComplexity), true

	case "KnowledgeBase.description":
		if e.complexity.KnowledgeBase.Description == nil {
			break
		}

		return e.complexity.KnowledgeBase.Description(childComplexity), true

	case "KnowledgeBase.displayName":
		if e.complexity.KnowledgeBase.DisplayName == nil {
			break
		}

		return e.complexity.KnowledgeBase.DisplayName(childComplexity), true

	case "KnowledgeBase.embedder":
		if e.complexity.KnowledgeBase.Embedder == nil {
			break
		}

		return e.complexity.KnowledgeBase.Embedder(childComplexity), true

	case "KnowledgeBase.fileGroupDetails":
		if e.complexity.KnowledgeBase.FileGroupDetails == nil {
			break
		}

		return e.complexity.KnowledgeBase.FileGroupDetails(childComplexity), true

	case "KnowledgeBase.id":
		if e.complexity.KnowledgeBase.ID == nil {
			break
		}

		return e.complexity.KnowledgeBase.ID(childComplexity), true

	case "KnowledgeBase.labels":
		if e.complexity.KnowledgeBase.Labels == nil {
			break
		}

		return e.complexity.KnowledgeBase.Labels(childComplexity), true

	case "KnowledgeBase.message":
		if e.complexity.KnowledgeBase.Message == nil {
			break
		}

		return e.complexity.KnowledgeBase.Message(childComplexity), true

	case "KnowledgeBase.name":
		if e.complexity.KnowledgeBase.Name == nil {
			break
		}

		return e.complexity.KnowledgeBase.Name(childComplexity), true

	case "KnowledgeBase.namespace":
		if e.complexity.KnowledgeBase.Namespace == nil {
			break
		}

		return e.complexity.KnowledgeBase.Namespace(childComplexity), true

	case "KnowledgeBase.reason":
		if e.complexity.KnowledgeBase.Reason == nil {
			break
		}

		return e.complexity.KnowledgeBase.Reason(childComplexity), true

	case "KnowledgeBase.status":
		if e.complexity.KnowledgeBase.Status == nil {
			break
		}

		return e.complexity.KnowledgeBase.Status(childComplexity), true

	case "KnowledgeBase.updateTimestamp":
		if e.complexity.KnowledgeBase.UpdateTimestamp == nil {
			break
		}

		return e.complexity.KnowledgeBase.UpdateTimestamp(childComplexity), true

	case "KnowledgeBase.vectorStore":
		if e.complexity.KnowledgeBase.VectorStore == nil {
			break
		}

		return e.complexity.KnowledgeBase.VectorStore(childComplexity), true

	case "KnowledgeBaseMutation.createKnowledgeBase":
		if e.complexity.KnowledgeBaseMutation.CreateKnowledgeBase == nil {
			break
		}

		args, err := ec.field_KnowledgeBaseMutation_createKnowledgeBase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KnowledgeBaseMutation.CreateKnowledgeBase(childComplexity, args["input"].(CreateKnowledgeBaseInput)), true

	case "KnowledgeBaseMutation.deleteKnowledgeBase":
		if e.complexity.KnowledgeBaseMutation.DeleteKnowledgeBase == nil {
			break
		}

		args, err := ec.field_KnowledgeBaseMutation_deleteKnowledgeBase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KnowledgeBaseMutation.DeleteKnowledgeBase(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "KnowledgeBaseMutation.updateKnowledgeBase":
		if e.complexity.KnowledgeBaseMutation.UpdateKnowledgeBase == nil {
			break
		}

		args, err := ec.field_KnowledgeBaseMutation_updateKnowledgeBase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KnowledgeBaseMutation.UpdateKnowledgeBase(childComplexity, args["input"].(*UpdateKnowledgeBaseInput)), true

	case "KnowledgeBaseQuery.getKnowledgeBase":
		if e.complexity.KnowledgeBaseQuery.GetKnowledgeBase == nil {
			break
		}

		args, err := ec.field_KnowledgeBaseQuery_getKnowledgeBase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KnowledgeBaseQuery.GetKnowledgeBase(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "KnowledgeBaseQuery.listKnowledgeBases":
		if e.complexity.KnowledgeBaseQuery.ListKnowledgeBases == nil {
			break
		}

		args, err := ec.field_KnowledgeBaseQuery_listKnowledgeBases_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.KnowledgeBaseQuery.ListKnowledgeBases(childComplexity, args["input"].(ListKnowledgeBaseInput)), true

	case "LLM.annotations":
		if e.complexity.LLM.Annotations == nil {
			break
		}

		return e.complexity.LLM.Annotations(childComplexity), true

	case "LLM.baseUrl":
		if e.complexity.LLM.BaseURL == nil {
			break
		}

		return e.complexity.LLM.BaseURL(childComplexity), true

	case "LLM.creationTimestamp":
		if e.complexity.LLM.CreationTimestamp == nil {
			break
		}

		return e.complexity.LLM.CreationTimestamp(childComplexity), true

	case "LLM.creator":
		if e.complexity.LLM.Creator == nil {
			break
		}

		return e.complexity.LLM.Creator(childComplexity), true

	case "LLM.description":
		if e.complexity.LLM.Description == nil {
			break
		}

		return e.complexity.LLM.Description(childComplexity), true

	case "LLM.displayName":
		if e.complexity.LLM.DisplayName == nil {
			break
		}

		return e.complexity.LLM.DisplayName(childComplexity), true

	case "LLM.id":
		if e.complexity.LLM.ID == nil {
			break
		}

		return e.complexity.LLM.ID(childComplexity), true

	case "LLM.labels":
		if e.complexity.LLM.Labels == nil {
			break
		}

		return e.complexity.LLM.Labels(childComplexity), true

	case "LLM.message":
		if e.complexity.LLM.Message == nil {
			break
		}

		return e.complexity.LLM.Message(childComplexity), true

	case "LLM.models":
		if e.complexity.LLM.Models == nil {
			break
		}

		return e.complexity.LLM.Models(childComplexity), true

	case "LLM.name":
		if e.complexity.LLM.Name == nil {
			break
		}

		return e.complexity.LLM.Name(childComplexity), true

	case "LLM.namespace":
		if e.complexity.LLM.Namespace == nil {
			break
		}

		return e.complexity.LLM.Namespace(childComplexity), true

	case "LLM.provider":
		if e.complexity.LLM.Provider == nil {
			break
		}

		return e.complexity.LLM.Provider(childComplexity), true

	case "LLM.status":
		if e.complexity.LLM.Status == nil {
			break
		}

		return e.complexity.LLM.Status(childComplexity), true

	case "LLM.type":
		if e.complexity.LLM.Type == nil {
			break
		}

		return e.complexity.LLM.Type(childComplexity), true

	case "LLM.updateTimestamp":
		if e.complexity.LLM.UpdateTimestamp == nil {
			break
		}

		return e.complexity.LLM.UpdateTimestamp(childComplexity), true

	case "LLMConfig.max_tokens":
		if e.complexity.LLMConfig.MaxTokens == nil {
			break
		}

		return e.complexity.LLMConfig.MaxTokens(childComplexity), true

	case "LLMConfig.model":
		if e.complexity.LLMConfig.Model == nil {
			break
		}

		return e.complexity.LLMConfig.Model(childComplexity), true

	case "LLMConfig.name":
		if e.complexity.LLMConfig.Name == nil {
			break
		}

		return e.complexity.LLMConfig.Name(childComplexity), true

	case "LLMConfig.namespace":
		if e.complexity.LLMConfig.Namespace == nil {
			break
		}

		return e.complexity.LLMConfig.Namespace(childComplexity), true

	case "LLMConfig.prompt_template":
		if e.complexity.LLMConfig.PromptTemplate == nil {
			break
		}

		return e.complexity.LLMConfig.PromptTemplate(childComplexity), true

	case "LLMConfig.provider":
		if e.complexity.LLMConfig.Provider == nil {
			break
		}

		return e.complexity.LLMConfig.Provider(childComplexity), true

	case "LLMConfig.temperature":
		if e.complexity.LLMConfig.Temperature == nil {
			break
		}

		return e.complexity.LLMConfig.Temperature(childComplexity), true

	case "LLMConfig.top_p":
		if e.complexity.LLMConfig.TopP == nil {
			break
		}

		return e.complexity.LLMConfig.TopP(childComplexity), true

	case "LLMQuery.getLLM":
		if e.complexity.LLMQuery.GetLlm == nil {
			break
		}

		args, err := ec.field_LLMQuery_getLLM_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LLMQuery.GetLlm(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "LLMQuery.listLLMs":
		if e.complexity.LLMQuery.ListLLMs == nil {
			break
		}

		args, err := ec.field_LLMQuery_listLLMs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LLMQuery.ListLLMs(childComplexity, args["input"].(ListCommonInput)), true

	case "Model.annotations":
		if e.complexity.Model.Annotations == nil {
			break
		}

		return e.complexity.Model.Annotations(childComplexity), true

	case "Model.creationTimestamp":
		if e.complexity.Model.CreationTimestamp == nil {
			break
		}

		return e.complexity.Model.CreationTimestamp(childComplexity), true

	case "Model.creator":
		if e.complexity.Model.Creator == nil {
			break
		}

		return e.complexity.Model.Creator(childComplexity), true

	case "Model.description":
		if e.complexity.Model.Description == nil {
			break
		}

		return e.complexity.Model.Description(childComplexity), true

	case "Model.displayName":
		if e.complexity.Model.DisplayName == nil {
			break
		}

		return e.complexity.Model.DisplayName(childComplexity), true

	case "Model.files":
		if e.complexity.Model.Files == nil {
			break
		}

		args, err := ec.field_Model_files_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Model.Files(childComplexity, args["input"].(*FileFilter)), true

	case "Model.id":
		if e.complexity.Model.ID == nil {
			break
		}

		return e.complexity.Model.ID(childComplexity), true

	case "Model.labels":
		if e.complexity.Model.Labels == nil {
			break
		}

		return e.complexity.Model.Labels(childComplexity), true

	case "Model.message":
		if e.complexity.Model.Message == nil {
			break
		}

		return e.complexity.Model.Message(childComplexity), true

	case "Model.name":
		if e.complexity.Model.Name == nil {
			break
		}

		return e.complexity.Model.Name(childComplexity), true

	case "Model.namespace":
		if e.complexity.Model.Namespace == nil {
			break
		}

		return e.complexity.Model.Namespace(childComplexity), true

	case "Model.status":
		if e.complexity.Model.Status == nil {
			break
		}

		return e.complexity.Model.Status(childComplexity), true

	case "Model.systemModel":
		if e.complexity.Model.SystemModel == nil {
			break
		}

		return e.complexity.Model.SystemModel(childComplexity), true

	case "Model.types":
		if e.complexity.Model.Types == nil {
			break
		}

		return e.complexity.Model.Types(childComplexity), true

	case "Model.updateTimestamp":
		if e.complexity.Model.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Model.UpdateTimestamp(childComplexity), true

	case "ModelMutation.createModel":
		if e.complexity.ModelMutation.CreateModel == nil {
			break
		}

		args, err := ec.field_ModelMutation_createModel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelMutation.CreateModel(childComplexity, args["input"].(CreateModelInput)), true

	case "ModelMutation.deleteModels":
		if e.complexity.ModelMutation.DeleteModels == nil {
			break
		}

		args, err := ec.field_ModelMutation_deleteModels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelMutation.DeleteModels(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "ModelMutation.updateModel":
		if e.complexity.ModelMutation.UpdateModel == nil {
			break
		}

		args, err := ec.field_ModelMutation_updateModel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelMutation.UpdateModel(childComplexity, args["input"].(*UpdateModelInput)), true

	case "ModelQuery.getModel":
		if e.complexity.ModelQuery.GetModel == nil {
			break
		}

		args, err := ec.field_ModelQuery_getModel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelQuery.GetModel(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "ModelQuery.listModels":
		if e.complexity.ModelQuery.ListModels == nil {
			break
		}

		args, err := ec.field_ModelQuery_listModels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelQuery.ListModels(childComplexity, args["input"].(ListModelInput)), true

	case "ModelService.apiType":
		if e.complexity.ModelService.APIType == nil {
			break
		}

		return e.complexity.ModelService.APIType(childComplexity), true

	case "ModelService.annotations":
		if e.complexity.ModelService.Annotations == nil {
			break
		}

		return e.complexity.ModelService.Annotations(childComplexity), true

	case "ModelService.baseUrl":
		if e.complexity.ModelService.BaseURL == nil {
			break
		}

		return e.complexity.ModelService.BaseURL(childComplexity), true

	case "ModelService.creationTimestamp":
		if e.complexity.ModelService.CreationTimestamp == nil {
			break
		}

		return e.complexity.ModelService.CreationTimestamp(childComplexity), true

	case "ModelService.creator":
		if e.complexity.ModelService.Creator == nil {
			break
		}

		return e.complexity.ModelService.Creator(childComplexity), true

	case "ModelService.description":
		if e.complexity.ModelService.Description == nil {
			break
		}

		return e.complexity.ModelService.Description(childComplexity), true

	case "ModelService.displayName":
		if e.complexity.ModelService.DisplayName == nil {
			break
		}

		return e.complexity.ModelService.DisplayName(childComplexity), true

	case "ModelService.embeddingModels":
		if e.complexity.ModelService.EmbeddingModels == nil {
			break
		}

		return e.complexity.ModelService.EmbeddingModels(childComplexity), true

	case "ModelService.id":
		if e.complexity.ModelService.ID == nil {
			break
		}

		return e.complexity.ModelService.ID(childComplexity), true

	case "ModelService.labels":
		if e.complexity.ModelService.Labels == nil {
			break
		}

		return e.complexity.ModelService.Labels(childComplexity), true

	case "ModelService.llmModels":
		if e.complexity.ModelService.LlmModels == nil {
			break
		}

		return e.complexity.ModelService.LlmModels(childComplexity), true

	case "ModelService.message":
		if e.complexity.ModelService.Message == nil {
			break
		}

		return e.complexity.ModelService.Message(childComplexity), true

	case "ModelService.name":
		if e.complexity.ModelService.Name == nil {
			break
		}

		return e.complexity.ModelService.Name(childComplexity), true

	case "ModelService.namespace":
		if e.complexity.ModelService.Namespace == nil {
			break
		}

		return e.complexity.ModelService.Namespace(childComplexity), true

	case "ModelService.providerType":
		if e.complexity.ModelService.ProviderType == nil {
			break
		}

		return e.complexity.ModelService.ProviderType(childComplexity), true

	case "ModelService.status":
		if e.complexity.ModelService.Status == nil {
			break
		}

		return e.complexity.ModelService.Status(childComplexity), true

	case "ModelService.types":
		if e.complexity.ModelService.Types == nil {
			break
		}

		return e.complexity.ModelService.Types(childComplexity), true

	case "ModelService.updateTimestamp":
		if e.complexity.ModelService.UpdateTimestamp == nil {
			break
		}

		return e.complexity.ModelService.UpdateTimestamp(childComplexity), true

	case "ModelServiceMutation.createModelService":
		if e.complexity.ModelServiceMutation.CreateModelService == nil {
			break
		}

		args, err := ec.field_ModelServiceMutation_createModelService_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceMutation.CreateModelService(childComplexity, args["input"].(CreateModelServiceInput)), true

	case "ModelServiceMutation.deleteModelService":
		if e.complexity.ModelServiceMutation.DeleteModelService == nil {
			break
		}

		args, err := ec.field_ModelServiceMutation_deleteModelService_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceMutation.DeleteModelService(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "ModelServiceMutation.updateModelService":
		if e.complexity.ModelServiceMutation.UpdateModelService == nil {
			break
		}

		args, err := ec.field_ModelServiceMutation_updateModelService_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceMutation.UpdateModelService(childComplexity, args["input"].(*UpdateModelServiceInput)), true

	case "ModelServiceQuery.checkModelService":
		if e.complexity.ModelServiceQuery.CheckModelService == nil {
			break
		}

		args, err := ec.field_ModelServiceQuery_checkModelService_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceQuery.CheckModelService(childComplexity, args["input"].(CreateModelServiceInput)), true

	case "ModelServiceQuery.getModelService":
		if e.complexity.ModelServiceQuery.GetModelService == nil {
			break
		}

		args, err := ec.field_ModelServiceQuery_getModelService_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceQuery.GetModelService(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "ModelServiceQuery.listModelServices":
		if e.complexity.ModelServiceQuery.ListModelServices == nil {
			break
		}

		args, err := ec.field_ModelServiceQuery_listModelServices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ModelServiceQuery.ListModelServices(childComplexity, args["input"].(*ListModelServiceInput)), true

	case "Mutation.Application":
		if e.complexity.Mutation.Application == nil {
			break
		}

		return e.complexity.Mutation.Application(childComplexity), true

	case "Mutation.dataProcess":
		if e.complexity.Mutation.DataProcess == nil {
			break
		}

		return e.complexity.Mutation.DataProcess(childComplexity), true

	case "Mutation.Dataset":
		if e.complexity.Mutation.Dataset == nil {
			break
		}

		return e.complexity.Mutation.Dataset(childComplexity), true

	case "Mutation.Datasource":
		if e.complexity.Mutation.Datasource == nil {
			break
		}

		return e.complexity.Mutation.Datasource(childComplexity), true

	case "Mutation.Embedder":
		if e.complexity.Mutation.Embedder == nil {
			break
		}

		return e.complexity.Mutation.Embedder(childComplexity), true

	case "Mutation.hello":
		if e.complexity.Mutation.Hello == nil {
			break
		}

		args, err := ec.field_Mutation_hello_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Hello(childComplexity, args["name"].(string)), true

	case "Mutation.KnowledgeBase":
		if e.complexity.Mutation.KnowledgeBase == nil {
			break
		}

		return e.complexity.Mutation.KnowledgeBase(childComplexity), true

	case "Mutation.Model":
		if e.complexity.Mutation.Model == nil {
			break
		}

		return e.complexity.Mutation.Model(childComplexity), true

	case "Mutation.ModelService":
		if e.complexity.Mutation.ModelService == nil {
			break
		}

		return e.complexity.Mutation.ModelService(childComplexity), true

	case "Mutation.VersionedDataset":
		if e.complexity.Mutation.VersionedDataset == nil {
			break
		}

		return e.complexity.Mutation.VersionedDataset(childComplexity), true

	case "Mutation.Worker":
		if e.complexity.Mutation.Worker == nil {
			break
		}

		return e.complexity.Mutation.Worker(childComplexity), true

	case "Oss.bucket":
		if e.complexity.Oss.Bucket == nil {
			break
		}

		return e.complexity.Oss.Bucket(childComplexity), true

	case "Oss.object":
		if e.complexity.Oss.Object == nil {
			break
		}

		return e.complexity.Oss.Object(childComplexity), true

	case "PaginatedDataProcessItem.data":
		if e.complexity.PaginatedDataProcessItem.Data == nil {
			break
		}

		return e.complexity.PaginatedDataProcessItem.Data(childComplexity), true

	case "PaginatedDataProcessItem.message":
		if e.complexity.PaginatedDataProcessItem.Message == nil {
			break
		}

		return e.complexity.PaginatedDataProcessItem.Message(childComplexity), true

	case "PaginatedDataProcessItem.status":
		if e.complexity.PaginatedDataProcessItem.Status == nil {
			break
		}

		return e.complexity.PaginatedDataProcessItem.Status(childComplexity), true

	case "PaginatedResult.hasNextPage":
		if e.complexity.PaginatedResult.HasNextPage == nil {
			break
		}

		return e.complexity.PaginatedResult.HasNextPage(childComplexity), true

	case "PaginatedResult.nodes":
		if e.complexity.PaginatedResult.Nodes == nil {
			break
		}

		return e.complexity.PaginatedResult.Nodes(childComplexity), true

	case "PaginatedResult.page":
		if e.complexity.PaginatedResult.Page == nil {
			break
		}

		return e.complexity.PaginatedResult.Page(childComplexity), true

	case "PaginatedResult.pageSize":
		if e.complexity.PaginatedResult.PageSize == nil {
			break
		}

		return e.complexity.PaginatedResult.PageSize(childComplexity), true

	case "PaginatedResult.totalCount":
		if e.complexity.PaginatedResult.TotalCount == nil {
			break
		}

		return e.complexity.PaginatedResult.TotalCount(childComplexity), true

	case "Query.Application":
		if e.complexity.Query.Application == nil {
			break
		}

		return e.complexity.Query.Application(childComplexity), true

	case "Query.dataProcess":
		if e.complexity.Query.DataProcess == nil {
			break
		}

		return e.complexity.Query.DataProcess(childComplexity), true

	case "Query.Dataset":
		if e.complexity.Query.Dataset == nil {
			break
		}

		return e.complexity.Query.Dataset(childComplexity), true

	case "Query.Datasource":
		if e.complexity.Query.Datasource == nil {
			break
		}

		return e.complexity.Query.Datasource(childComplexity), true

	case "Query.Embedder":
		if e.complexity.Query.Embedder == nil {
			break
		}

		return e.complexity.Query.Embedder(childComplexity), true

	case "Query.hello":
		if e.complexity.Query.Hello == nil {
			break
		}

		args, err := ec.field_Query_hello_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hello(childComplexity, args["name"].(string)), true

	case "Query.KnowledgeBase":
		if e.complexity.Query.KnowledgeBase == nil {
			break
		}

		return e.complexity.Query.KnowledgeBase(childComplexity), true

	case "Query.LLM":
		if e.complexity.Query.Llm == nil {
			break
		}

		return e.complexity.Query.Llm(childComplexity), true

	case "Query.Model":
		if e.complexity.Query.Model == nil {
			break
		}

		return e.complexity.Query.Model(childComplexity), true

	case "Query.ModelService":
		if e.complexity.Query.ModelService == nil {
			break
		}

		return e.complexity.Query.ModelService(childComplexity), true

	case "Query.VersionedDataset":
		if e.complexity.Query.VersionedDataset == nil {
			break
		}

		return e.complexity.Query.VersionedDataset(childComplexity), true

	case "Query.Worker":
		if e.complexity.Query.Worker == nil {
			break
		}

		return e.complexity.Query.Worker(childComplexity), true

	case "Resources.cpu":
		if e.complexity.Resources.CPU == nil {
			break
		}

		return e.complexity.Resources.CPU(childComplexity), true

	case "Resources.memory":
		if e.complexity.Resources.Memory == nil {
			break
		}

		return e.complexity.Resources.Memory(childComplexity), true

	case "Resources.nvidiaGPU":
		if e.complexity.Resources.NvidiaGpu == nil {
			break
		}

		return e.complexity.Resources.NvidiaGpu(childComplexity), true

	case "TypedObjectReference.apiGroup":
		if e.complexity.TypedObjectReference.APIGroup == nil {
			break
		}

		return e.complexity.TypedObjectReference.APIGroup(childComplexity), true

	case "TypedObjectReference.kind":
		if e.complexity.TypedObjectReference.Kind == nil {
			break
		}

		return e.complexity.TypedObjectReference.Kind(childComplexity), true

	case "TypedObjectReference.name":
		if e.complexity.TypedObjectReference.Name == nil {
			break
		}

		return e.complexity.TypedObjectReference.Name(childComplexity), true

	case "TypedObjectReference.namespace":
		if e.complexity.TypedObjectReference.Namespace == nil {
			break
		}

		return e.complexity.TypedObjectReference.Namespace(childComplexity), true

	case "VersionedDataset.annotations":
		if e.complexity.VersionedDataset.Annotations == nil {
			break
		}

		return e.complexity.VersionedDataset.Annotations(childComplexity), true

	case "VersionedDataset.creationTimestamp":
		if e.complexity.VersionedDataset.CreationTimestamp == nil {
			break
		}

		return e.complexity.VersionedDataset.CreationTimestamp(childComplexity), true

	case "VersionedDataset.creator":
		if e.complexity.VersionedDataset.Creator == nil {
			break
		}

		return e.complexity.VersionedDataset.Creator(childComplexity), true

	case "VersionedDataset.dataProcessStatus":
		if e.complexity.VersionedDataset.DataProcessStatus == nil {
			break
		}

		return e.complexity.VersionedDataset.DataProcessStatus(childComplexity), true

	case "VersionedDataset.dataset":
		if e.complexity.VersionedDataset.Dataset == nil {
			break
		}

		return e.complexity.VersionedDataset.Dataset(childComplexity), true

	case "VersionedDataset.description":
		if e.complexity.VersionedDataset.Description == nil {
			break
		}

		return e.complexity.VersionedDataset.Description(childComplexity), true

	case "VersionedDataset.displayName":
		if e.complexity.VersionedDataset.DisplayName == nil {
			break
		}

		return e.complexity.VersionedDataset.DisplayName(childComplexity), true

	case "VersionedDataset.files":
		if e.complexity.VersionedDataset.Files == nil {
			break
		}

		args, err := ec.field_VersionedDataset_files_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDataset.Files(childComplexity, args["input"].(*FileFilter)), true

	case "VersionedDataset.id":
		if e.complexity.VersionedDataset.ID == nil {
			break
		}

		return e.complexity.VersionedDataset.ID(childComplexity), true

	case "VersionedDataset.labels":
		if e.complexity.VersionedDataset.Labels == nil {
			break
		}

		return e.complexity.VersionedDataset.Labels(childComplexity), true

	case "VersionedDataset.name":
		if e.complexity.VersionedDataset.Name == nil {
			break
		}

		return e.complexity.VersionedDataset.Name(childComplexity), true

	case "VersionedDataset.namespace":
		if e.complexity.VersionedDataset.Namespace == nil {
			break
		}

		return e.complexity.VersionedDataset.Namespace(childComplexity), true

	case "VersionedDataset.released":
		if e.complexity.VersionedDataset.Released == nil {
			break
		}

		return e.complexity.VersionedDataset.Released(childComplexity), true

	case "VersionedDataset.syncStatus":
		if e.complexity.VersionedDataset.SyncStatus == nil {
			break
		}

		return e.complexity.VersionedDataset.SyncStatus(childComplexity), true

	case "VersionedDataset.updateTimestamp":
		if e.complexity.VersionedDataset.UpdateTimestamp == nil {
			break
		}

		return e.complexity.VersionedDataset.UpdateTimestamp(childComplexity), true

	case "VersionedDataset.version":
		if e.complexity.VersionedDataset.Version == nil {
			break
		}

		return e.complexity.VersionedDataset.Version(childComplexity), true

	case "VersionedDatasetMutation.createVersionedDataset":
		if e.complexity.VersionedDatasetMutation.CreateVersionedDataset == nil {
			break
		}

		args, err := ec.field_VersionedDatasetMutation_createVersionedDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDatasetMutation.CreateVersionedDataset(childComplexity, args["input"].(CreateVersionedDatasetInput)), true

	case "VersionedDatasetMutation.deleteVersionedDatasets":
		if e.complexity.VersionedDatasetMutation.DeleteVersionedDatasets == nil {
			break
		}

		args, err := ec.field_VersionedDatasetMutation_deleteVersionedDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDatasetMutation.DeleteVersionedDatasets(childComplexity, args["input"].(DeleteVersionedDatasetInput)), true

	case "VersionedDatasetMutation.updateVersionedDataset":
		if e.complexity.VersionedDatasetMutation.UpdateVersionedDataset == nil {
			break
		}

		args, err := ec.field_VersionedDatasetMutation_updateVersionedDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDatasetMutation.UpdateVersionedDataset(childComplexity, args["input"].(UpdateVersionedDatasetInput)), true

	case "VersionedDatasetQuery.getVersionedDataset":
		if e.complexity.VersionedDatasetQuery.GetVersionedDataset == nil {
			break
		}

		args, err := ec.field_VersionedDatasetQuery_getVersionedDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDatasetQuery.GetVersionedDataset(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "VersionedDatasetQuery.listVersionedDatasets":
		if e.complexity.VersionedDatasetQuery.ListVersionedDatasets == nil {
			break
		}

		args, err := ec.field_VersionedDatasetQuery_listVersionedDatasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.VersionedDatasetQuery.ListVersionedDatasets(childComplexity, args["input"].(ListVersionedDatasetInput)), true

	case "Worker.api":
		if e.complexity.Worker.API == nil {
			break
		}

		return e.complexity.Worker.API(childComplexity), true

	case "Worker.annotations":
		if e.complexity.Worker.Annotations == nil {
			break
		}

		return e.complexity.Worker.Annotations(childComplexity), true

	case "Worker.creationTimestamp":
		if e.complexity.Worker.CreationTimestamp == nil {
			break
		}

		return e.complexity.Worker.CreationTimestamp(childComplexity), true

	case "Worker.creator":
		if e.complexity.Worker.Creator == nil {
			break
		}

		return e.complexity.Worker.Creator(childComplexity), true

	case "Worker.description":
		if e.complexity.Worker.Description == nil {
			break
		}

		return e.complexity.Worker.Description(childComplexity), true

	case "Worker.displayName":
		if e.complexity.Worker.DisplayName == nil {
			break
		}

		return e.complexity.Worker.DisplayName(childComplexity), true

	case "Worker.id":
		if e.complexity.Worker.ID == nil {
			break
		}

		return e.complexity.Worker.ID(childComplexity), true

	case "Worker.labels":
		if e.complexity.Worker.Labels == nil {
			break
		}

		return e.complexity.Worker.Labels(childComplexity), true

	case "Worker.message":
		if e.complexity.Worker.Message == nil {
			break
		}

		return e.complexity.Worker.Message(childComplexity), true

	case "Worker.model":
		if e.complexity.Worker.Model == nil {
			break
		}

		return e.complexity.Worker.Model(childComplexity), true

	case "Worker.modelTypes":
		if e.complexity.Worker.ModelTypes == nil {
			break
		}

		return e.complexity.Worker.ModelTypes(childComplexity), true

	case "Worker.name":
		if e.complexity.Worker.Name == nil {
			break
		}

		return e.complexity.Worker.Name(childComplexity), true

	case "Worker.namespace":
		if e.complexity.Worker.Namespace == nil {
			break
		}

		return e.complexity.Worker.Namespace(childComplexity), true

	case "Worker.replicas":
		if e.complexity.Worker.Replicas == nil {
			break
		}

		return e.complexity.Worker.Replicas(childComplexity), true

	case "Worker.resources":
		if e.complexity.Worker.Resources == nil {
			break
		}

		return e.complexity.Worker.Resources(childComplexity), true

	case "Worker.status":
		if e.complexity.Worker.Status == nil {
			break
		}

		return e.complexity.Worker.Status(childComplexity), true

	case "Worker.type":
		if e.complexity.Worker.Type == nil {
			break
		}

		return e.complexity.Worker.Type(childComplexity), true

	case "Worker.updateTimestamp":
		if e.complexity.Worker.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Worker.UpdateTimestamp(childComplexity), true

	case "WorkerMutation.createWorker":
		if e.complexity.WorkerMutation.CreateWorker == nil {
			break
		}

		args, err := ec.field_WorkerMutation_createWorker_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkerMutation.CreateWorker(childComplexity, args["input"].(CreateWorkerInput)), true

	case "WorkerMutation.deleteWorkers":
		if e.complexity.WorkerMutation.DeleteWorkers == nil {
			break
		}

		args, err := ec.field_WorkerMutation_deleteWorkers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkerMutation.DeleteWorkers(childComplexity, args["input"].(*DeleteCommonInput)), true

	case "WorkerMutation.updateWorker":
		if e.complexity.WorkerMutation.UpdateWorker == nil {
			break
		}

		args, err := ec.field_WorkerMutation_updateWorker_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkerMutation.UpdateWorker(childComplexity, args["input"].(*UpdateWorkerInput)), true

	case "WorkerQuery.getWorker":
		if e.complexity.WorkerQuery.GetWorker == nil {
			break
		}

		args, err := ec.field_WorkerQuery_getWorker_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkerQuery.GetWorker(childComplexity, args["name"].(string), args["namespace"].(string)), true

	case "WorkerQuery.listWorkers":
		if e.complexity.WorkerQuery.ListWorkers == nil {
			break
		}

		args, err := ec.field_WorkerQuery_listWorkers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.WorkerQuery.ListWorkers(childComplexity, args["input"].(ListWorkerInput)), true

	case "filedetail.count":
		if e.complexity.Filedetail.Count == nil {
			break
		}

		return e.complexity.Filedetail.Count(childComplexity), true

	case "filedetail.fileType":
		if e.complexity.Filedetail.FileType == nil {
			break
		}

		return e.complexity.Filedetail.FileType(childComplexity), true

	case "filedetail.path":
		if e.complexity.Filedetail.Path == nil {
			break
		}

		return e.complexity.Filedetail.Path(childComplexity), true

	case "filedetail.phase":
		if e.complexity.Filedetail.Phase == nil {
			break
		}

		return e.complexity.Filedetail.Phase(childComplexity), true

	case "filedetail.size":
		if e.complexity.Filedetail.Size == nil {
			break
		}

		return e.complexity.Filedetail.Size(childComplexity), true

	case "filedetail.updateTimestamp":
		if e.complexity.Filedetail.UpdateTimestamp == nil {
			break
		}

		return e.complexity.Filedetail.UpdateTimestamp(childComplexity), true

	case "filegroup.path":
		if e.complexity.Filegroup.Path == nil {
			break
		}

		return e.complexity.Filegroup.Path(childComplexity), true

	case "filegroup.source":
		if e.complexity.Filegroup.Source == nil {
			break
		}

		return e.complexity.Filegroup.Source(childComplexity), true

	case "filegroupdetail.filedetails":
		if e.complexity.Filegroupdetail.Filedetails == nil {
			break
		}

		return e.complexity.Filegroupdetail.Filedetails(childComplexity), true

	case "filegroupdetail.source":
		if e.complexity.Filegroupdetail.Source == nil {
			break
		}

		return e.complexity.Filegroupdetail.Source(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddDataProcessInput,
		ec.unmarshalInputAllDataProcessListByCountInput,
		ec.unmarshalInputAllDataProcessListByPageInput,
		ec.unmarshalInputCheckDataProcessTaskNameInput,
		ec.unmarshalInputCreateApplicationMetadataInput,
		ec.unmarshalInputCreateDatasetInput,
		ec.unmarshalInputCreateDatasourceInput,
		ec.unmarshalInputCreateEmbedderInput,
		ec.unmarshalInputCreateKnowledgeBaseInput,
		ec.unmarshalInputCreateLLMInput,
		ec.unmarshalInputCreateModelInput,
		ec.unmarshalInputCreateModelServiceInput,
		ec.unmarshalInputCreateVersionedDatasetInput,
		ec.unmarshalInputCreateWorkerInput,
		ec.unmarshalInputDataProcessConfigItem,
		ec.unmarshalInputDataProcessDetailsInput,
		ec.unmarshalInputDeleteCommonInput,
		ec.unmarshalInputDeleteDataProcessInput,
		ec.unmarshalInputDeleteVersionedDatasetInput,
		ec.unmarshalInputEndpointInput,
		ec.unmarshalInputFileFilter,
		ec.unmarshalInputFileGroup,
		ec.unmarshalInputFileItem,
		ec.unmarshalInputLLMConfigItem,
		ec.unmarshalInputListCommonInput,
		ec.unmarshalInputListDatasetInput,
		ec.unmarshalInputListKnowledgeBaseInput,
		ec.unmarshalInputListModelInput,
		ec.unmarshalInputListModelServiceInput,
		ec.unmarshalInputListVersionedDatasetInput,
		ec.unmarshalInputListWorkerInput,
		ec.unmarshalInputOssInput,
		ec.unmarshalInputResourcesInput,
		ec.unmarshalInputTypedObjectReferenceInput,
		ec.unmarshalInputUpdateApplicationConfigInput,
		ec.unmarshalInputUpdateApplicationMetadataInput,
		ec.unmarshalInputUpdateDatasetInput,
		ec.unmarshalInputUpdateDatasourceInput,
		ec.unmarshalInputUpdateEmbedderInput,
		ec.unmarshalInputUpdateKnowledgeBaseInput,
		ec.unmarshalInputUpdateLLMInput,
		ec.unmarshalInputUpdateModelInput,
		ec.unmarshalInputUpdateModelServiceInput,
		ec.unmarshalInputUpdateVersionedDatasetInput,
		ec.unmarshalInputUpdateWorkerInput,
		ec.unmarshalInputfilegroupinput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/application.graphqls", Input: `type ApplicationQuery {
    getApplication(name: String!, namespace: String!): Application!
    listApplicationMetadata(input: ListCommonInput!): PaginatedResult!
}

type ApplicationMutation {
    createApplication(input: CreateApplicationMetadataInput!): ApplicationMetadata!
    updateApplication(input: UpdateApplicationMetadataInput!): ApplicationMetadata!
    deleteApplication(input: DeleteCommonInput!): Void
    updateApplicationConfig(input: UpdateApplicationConfigInput!): Application!
}
extend type Mutation {
    Application: ApplicationMutation
}
extend type Query{
    Application: ApplicationQuery
}

"""
Application
应用完整信息
"""
type Application {

    metadata: ApplicationMetadata

    """
    对话开场白
    """
    prologue: String

    """
    model 指具体使用的模型名称，比如 gpt-3.5-turbo 或者 chatglm_turbo
    """
    model: String

    """
    llm 指当前知识库应用使用的模型服务，即 Kind 为 LLM 的 CR 的名称
    """
    llm: String!

    """
    temperature 温度
    """
    temperature: Float

    """
    maxLength 最大响应长度
    """
    maxLength: Int

    """
    conversionWindowSize 对话轮次
    """
    conversionWindowSize: Int

    """
    knowledgebase 指当前知识库应用使用的知识库，即 Kind 为 KnowledgeBase 的 CR 的名称，目前一个应用只支持0或1个知识库
    """
    knowledgebase: String

    """
    scoreThreshold 最低相似度
    """
    scoreThreshold: Float

    """
    numDocuments  引用上限
    """
    numDocuments: Int

    """
    docNullReturn 空搜索回复
    """
    docNullReturn: String
    """
    userPrompt 用户级别的 Prompt
    """
    userPrompt: String

    """
    showNextGuide 下一步引导，是否显示下一步引导
    """
    showNextGuid: Boolean
}

"""
Application
应用 Metadata
"""
type ApplicationMetadata {
    """
    应用名称
    规则: 遵循 k8s 命名
    """
    name: String!

    """
    应用所在的 namespace
    规则: 非空
    """
    namespace: String!

    """
    应用id，为CR资源中的metadata.uid
    """
    id: String
    """
    一些用于标记，选择的的标签
    """
    labels: Map

    """
    添加一些辅助性记录信息
    """
    annotations: Map

    """
    展示名，别名
    """
    displayName: String

    """
    描述信息
    """
    description: String

    """
    Icon，应用头像， base64格式的图片
    """
    icon: String

    """
    创建者，为当前用户的用户名
    规则: webhook启用后自动添加，默认为空
    """
    creator: String

    """创建时间"""
    creationTimestamp: Time

    """更新时间"""
    updateTimestamp: Time

    """IsPublic, 是否发布，即是否公开提供服务"""
    isPublic: Boolean

    """
    应用状态
    """
    status: String
}

input CreateApplicationMetadataInput {
    """
    应用名称
    规则: 遵循 k8s 命名
    """
    name: String!

    """
    应用所在的namespace
    规则: 非空
    """
    namespace: String!

    """
    一些用于标记，选择的的标签
    """
    labels: Map

    """
    添加一些辅助性记录信息
    """
    annotations: Map

    """
    展示名，别名
    """
    displayName: String!

    """
    描述信息
    """
    description: String

    """
    Icon，应用头像， base64格式的图片
    """
    icon: String!

    """
    IsPublic, 是否发布，即是否公开提供服务
    """
    isPublic: Boolean
}

input UpdateApplicationMetadataInput {
    """
    应用名称, 用于确定要更新哪个应用
    规则: 遵循 k8s 命名
    """
    name: String!

    """
    应用所在的 namespace, 用于确定要更新哪个应用
    规则: 非空
    """
    namespace: String!

    """
    一些用于标记，选择的的标签，如果要更新，请传递完整内容
    """
    labels: Map

    """
    添加一些辅助性记录信息，如果要更新，请传递完整内容
    """
    annotations: Map

    """
    展示名，别名
    """
    displayName: String!

    """
    描述信息
    """
    description: String

    """
    Icon，应用头像， base64格式的图片
    """
    icon: String!

    """
    IsPublic, 是否发布，即是否公开提供服务
    """
    isPublic: Boolean
}

input UpdateApplicationConfigInput {
    """
    应用名称, 用于确定要更新哪个应用
    规则: 遵循 k8s 命名
    """
    name: String!

    """
    应用所在的 namespace, 用于确定要更新哪个应用
    规则: 非空
    """
    namespace: String!

    """
    对话开场白
    """
    prologue: String

    """
    model 指具体使用的模型名称，比如 gpt-3.5-turbo 或者 chatglm_turbo
    """
    model: String

    """
    llm 指当前知识库应用使用的模型服务，即 Kind 为 LLM 的 CR 的名称
    """
    llm: String!

    """
    temperature 温度
    """
    temperature: Float

    """
    maxLength 最大响应长度
    """
    maxLength: Int

    """
    conversionWindowSize 对话轮次
    """
    conversionWindowSize: Int

    """
    knowledgebase 指当前知识库应用使用的知识库，即 Kind 为 KnowledgeBase 的 CR 的名称，目前一个应用只支持0或1个知识库
    """
    knowledgebase: String

    """
    scoreThreshold 最低相似度
    """
    scoreThreshold: Float

    """
    numDocuments  引用上限
    """
    numDocuments: Int

    """
    docNullReturn 空搜索回复
    """
    docNullReturn: String
    """
    userPrompt 用户级别的 Prompt
    """
    userPrompt: String

    """
    showNextGuide 下一步引导，是否显示下一步引导
    """
    showNextGuid: Boolean
}
`, BuiltIn: false},
	{Name: "../schema/dataprocessing.graphqls", Input: `# 数据处理 Mutation
type DataProcessMutation {
  # 创建数据处理任务
  createDataProcessTask(input: AddDataProcessInput): DataProcessResponse
  # 删除数据处理任务
  deleteDataProcessTask(input: DeleteDataProcessInput): DataProcessResponse
}


# 数据处理 Query
type DataProcessQuery {
  # 数据处理列表 分页
  allDataProcessListByPage(input: AllDataProcessListByPageInput): PaginatedDataProcessItem
  # 数据处理列表 总记录数
  allDataProcessListByCount(input: AllDataProcessListByCountInput): CountDataProcessItem
  # 数据处理支持类型
  dataProcessSupportType: DataProcessSupportType
  # 数据处理详情
  dataProcessDetails(input: DataProcessDetailsInput): DataProcessDetails
  # 检验名称是否重复
  checkDataProcessTaskName(input: CheckDataProcessTaskNameInput): DataProcessResponse
}


input AllDataProcessListByPageInput {
  pageIndex: Int!
  pageSize: Int!
  keyword: String!
  namespace: String!
}

input AllDataProcessListByCountInput {
  keyword: String!
  namespace: String!
}

input AddDataProcessInput {
  name: String!
  file_type: String!
  pre_data_set_name: String!
  pre_data_set_version: String!
  file_names: [FileItem!]
  post_data_set_name: String!
  post_data_set_version: String!
  data_process_config_info: [DataProcessConfigItem!]
  bucket_name: String!
  version_data_set_name: String!
  namespace: String!
  creator: String!
}

# 文件条目
input FileItem {
  name: String!
}

# 数据处理配置条目
input DataProcessConfigItem {
  type: String!
  llm_config: LLMConfigItem
}

# LLM for 数据处理配置条目 
input LLMConfigItem {
  name: String
  namespace: String
  model: String
  temperature: String
  top_p: String
  max_tokens: String
  prompt_template: String
}

input DeleteDataProcessInput {
  id: String!
}

input DataProcessDetailsInput {
  id: String!
}

input CheckDataProcessTaskNameInput {
  name: String!
  namespace: String!
}

# 数据处理列表分页
type PaginatedDataProcessItem {
  status: Int!
  data: [DataProcessItem!]
  message: String!
}

# 数据处理列表总记录数
type CountDataProcessItem {
  status: Int!
  data: Int!
  message: String!
}

# 数据处理条目
type DataProcessItem {
  # 主键
  id: String!
  # 任务名称
  name: String!
  # 状态
  status: String!
  # 处理前数据集
  pre_data_set_name: String!
  # 处理前数据集版本
  pre_data_set_version: String!
  # 处理后数据集
  post_data_set_name:String!
  # 处理后数据集版本
  post_data_set_version: String
  # 开始时间
  start_datetime: String!
  # 错误日志
  error_msg: String
}

# 数据处理支持类型
type DataProcessSupportType {
  status: Int!
  data: [DataProcessSupportTypeItem!]
  message: String!
}

# 数据处理支持类型条目
type DataProcessSupportTypeItem {
  name: String!
  description: String!
  children: [DataProcessSupportTypeChildren!]
}

# 数据处理支持类型条目
type DataProcessSupportTypeChildren {
  name: String!
  zh_name: String!
  enable: String!
  description: String!
}

# 数据处理列表总记录数
type DataProcessResponse {
  status: Int!
  data: String!
  message: String!
}


# 数据处理详情
type DataProcessDetails {
  status: Int!
  data: DataProcessDetailsItem!
  message: String!
}

# 数据处理详情Item
type DataProcessDetailsItem {
  id: String!
  status: String!
  name: String!
  file_type: String!
  pre_dataset_name: String!
  pre_dataset_version: String!
  post_dataset_name: String!
  post_dataset_version: String!
  file_num: Int!
  start_time: String!
  end_time: String!
  creator: String!
  error_msg: String
  config: [DataProcessConfig!]
}

# 数据处理配置项
type DataProcessConfig {
  name: String!
  description: String!
  file_num: Int!
  status: String!
  children: [DataProcessConfigChildren]
}

# 数据处理配置项子项
type DataProcessConfigChildren {
  name: String
  enable: String
  zh_name: String
  description: String
  llm_config: LLMConfig
  preview: [DataProcessConfigpreView]
  file_progress: [DataProcessConfigpreFileProgress]
}

type LLMConfig {
  name: String
  namespace: String
  model: String
  temperature: String
  top_p: String
  max_tokens: String
  prompt_template: String
  provider: String
}

# 数据处理配置项预览
type DataProcessConfigpreView {
  file_name: String
  content: [DataProcessConfigpreViewContent]
}

# 数据处理配置项预览
type DataProcessConfigpreFileProgress {
  id: String
  file_name: String
  status: String
  start_time: String
  end_time: String
  progress: String
}

# 数据处理配置项预览内容
type DataProcessConfigpreViewContent {
  pre: String
  post: String
}


# mutation
extend type Mutation {
  dataProcess: DataProcessMutation
}

# query
extend type Query {
  dataProcess: DataProcessQuery
}`, BuiltIn: false},
	{Name: "../schema/dataset.graphqls", Input: `"""
Dataset
数据集代表用户纳管的一组相似属性的文件，采用相同的方式进行数据处理并用于后续的
1. 模型训练
2. 知识库

支持多种类型数据:
- 文本
- 图片
- 视频

单个数据集仅允许包含同一类型文件，不同类型文件将被忽略
数据集允许有多个版本，数据处理针对单个版本进行
数据集某个版本完成数据处理后，数据处理服务需要将处理后的存储回 版本数据集
"""
type Dataset {
    """
    名称
    规则: 遵循k8s命名
    """
    name: String!

    """
    所在的namespace(文件上传时作为bucket)
    规则: 获取当前项目对应的命名空间
    规则: 非空
    """
    namespace: String!

    """一些用于标记，选择的的标签"""
    labels: Map

    """添加一些辅助性记录信息"""
    annotations: Map

    """
    创建者，为当前用户的用户名
    规则: webhook启用后自动添加，默认为空
    """
    creator: String

    """展示名"""
    displayName: String

    """描述信息"""
    description: String

    """创建时间"""
    creationTimestamp: Time
    """更新时间, 这里更新指文件同步，或者数据处理完成后，做的更新操作的时间"""
    updateTimestamp: Time

    """
    数据集类型，文本，图片，视频
    规则: enum{ text image video}
    规则: 非空
    """
    contentType: String!

    """
    应用场景
    规则: enum{ xx xx } (非固定字段，以产品为准)
    """
    field: String
    """
    数据集下面的版本列表。
    规则: 支持对名字，类型的完全匹配过滤。
    规则: 支持通过标签(somelabel=abc)，字段(metadata.name=abc)进行过滤
    """
    versions(input: ListVersionedDatasetInput!): PaginatedResult!
}

"""数据集创建的输入"""
input CreateDatasetInput {
    """
    数据集的名字
    规则: k8s的名称规则
    规则: 非空
    """
    name: String!

    """
    数据集的命名空间
    规则: 非空
    """
    namespace: String!

    """一些标签选择信息，可以不添加"""
    labels: Map

    """一些备注用的注视信息，或者记录一个简单的配置"""
    annotations: Map

    """展示名称"""
    displayName: String
    
    """描述信息，可以不写"""
    description: String

    """数据集里面的数据的类型，文本，视频，图片"""
    contentType: String!

    """
    应用场景，可以为空
    规则: enum{ xx xx } (非固定字段，以产品为准)
    """
    filed: String
}

"""数据集更新的输入"""
input UpdateDatasetInput {
    """
    name, namespace用来确定资源
    规则: 不允许修改的。将原数据传递回来即可。
    """   
    name: String!
    namespace: String!

    """
    更新的的标签信息，这里涉及到增加或者删除标签，
    规则: 不允许修改的。将原数据传递回来即可。    
    如果标签有任何改动，传递完整的label。
    例如之前的标齐是: abc:def 新增一个标签aa:bb, 那么传递 abc:def, aa:bb
    """ 
    labels: Map
    annotations: Map
    
    """如不更新，则为空"""
    displayName: String

    """如不更新，则为空"""
    description: String
}

"""数据集分页列表查询的输入"""
input ListDatasetInput {
    """
    namespace用来确定资源
    规则: 必填
    """
    namespace: String!

    """name用来唯一确定资源"""
    name: String

    """展示名"""
    displayName: String

    """标签选择器"""    
    labelSelector: String
    """字段选择器"""   
    fieldSelector: String

    """
    分页页码，
    规则: 从1开始，默认是1
    """
    page: Int

    """
    每页数量，
    规则: 默认10
    """
    pageSize: Int

    """
    关键词: 模糊匹配
    规则: namespace,name,displayName,contentType,annotations中如果包含该字段则返回
    """
    keyword: String
}

"""数据集查询"""
type DatasetQuery {
    """根据名字获取某个具体的数据集"""
    getDataset(name: String!, namespace: String!): Dataset!

    """
    获取数据集列表
    规则: 支持通过标签和字段进行选择。如下:
    labelSelector: aa=bbb
    fieldSelector= metadata.name=somename
    """
    listDatasets(input: ListDatasetInput): PaginatedResult!
}

"""数据集更新"""
type DatasetMutation {
    """创建数据集"""
    createDataset(input: CreateDatasetInput): Dataset!
    """更新数据集"""
    updateDataset(input: UpdateDatasetInput): Dataset!

    """
    删除数据集
    规则: 支持删除一个名称列表中包含的所有数据集
    规则: 支持通过标签选择器，将满足标签的dataset全部删除
    规则: 如果提供了这两个参数，以名字列表为主。
    """
    deleteDatasets(input: DeleteCommonInput): Void
}

extend type Query {
    Dataset: DatasetQuery
}

extend type Mutation {
    Dataset: DatasetMutation
}
`, BuiltIn: false},
	{Name: "../schema/datasource.graphqls", Input: `"""终端的访问信息"""
type Endpoint {
    """url地址"""
    url: String
    """终端访问的密钥信息，保存在k8s secret中"""
    authSecret: TypedObjectReference
    """是否通过非安全方式访问，默认为false，即安全模式访问"""
    insecure: Boolean
}

"""对象存储的使用信息"""
type Oss {
    """所用的bucket名称"""
    bucket: String
    """所用的object路径(可为前缀)"""
    object: String
}

"""
数据源: 定义了对某一个具备数据存储能力服务的访问信息，供后续向该数据源获取数据使用
"""
type Datasource {
    """
    模型id,为CR资源中的metadata.uid
    """
    id: String

    """
    名称
    规则: 遵循k8s命名
    规则: 非空
    """
    name: String!
    """
    命名空间
    规则: 非空
    """
    namespace: String!

    labels: Map
    annotations: Map

    """
    创建者，为当前用户的用户名
    规则: webhook启用后自动添加，默认为空
    """
    creator: String
    """展示名"""
    displayName: String
    """描述信息"""
    description: String

    """终端访问信息"""
    endpoint: Endpoint

    """
    对象存储访问信息
    规则: 非空代表当前数据源为对象存储数据源
    """
    oss: Oss

    """数据源连接状态"""
    status: String

    message: String

    """创建时间"""
    creationTimestamp: Time
    """更新时间, 这里更新指文件同步，或者数据处理完成后，做的更新操作的时间"""
    updateTimestamp: Time
}

"""文件输入"""
input OssInput {
    bucket: String!
    object: String
}

"""新增数据源时输入条件"""
input CreateDatasourceInput {
    """
    名字
    规则: k8s的名称规则
    规则: 非空
    """
    name: String!

    """
    数据源的命名空间
    规则: 非空
    """
    namespace: String!

    """数据源资源标签"""
    labels: Map
    """数据源资源注释"""
    annotations: Map

    """数据源资源展示名称作为显示，并提供编辑"""
    displayName: String
    """数据源资源描述"""
    description: String

    """数据源的访问信息输入"""
    endpointinput: EndpointInput!

    """数据源为对象存储类型时的输入"""
    ossinput: OssInput
}

"""更新数据源的输入"""
input UpdateDatasourceInput {
    """
    name, namespace用来确定资源
    规则: 不允许修改的。将原数据传递回来即可。
    """
    name: String!
    namespace: String!

    """
    更新的的标签信息，这里涉及到增加或者删除标签，
    规则: 不允许修改的。将原数据传递回来即可。    
    如果标签有任何改动，传递完整的label。
    例如之前的标齐是: abc:def 新增一个标签aa:bb, 那么传递 abc:def, aa:bb
    """ 
    labels: Map
    annotations: Map

    """如不更新，则为空"""
    displayName: String
    """如不更新，则为空"""
    description: String

    """数据源的访问信息输入"""
    endpointinput: EndpointInput

    """数据源为对象存储类型时的输入"""
    ossinput: OssInput
}


type DatasourceQuery {
    getDatasource(name: String!, namespace: String!): Datasource!
    checkDatasource(input: CreateDatasourceInput!): Datasource!
    listDatasources(input: ListCommonInput!): PaginatedResult!
}

type DatasourceMutation {
    createDatasource(input: CreateDatasourceInput!): Datasource!
    updateDatasource(input: UpdateDatasourceInput): Datasource!
    deleteDatasources(input: DeleteCommonInput): Void
}
# mutation
extend type Mutation {
    Datasource: DatasourceMutation
}
# query
extend type Query{
    Datasource: DatasourceQuery
}
`, BuiltIn: false},
	{Name: "../schema/embedder.graphqls", Input: `type Embedder {
    id: String
    name: String!
    namespace: String!
    labels: Map
    annotations: Map
    creator: String
    displayName: String
    description: String

    """
    服务地址
    """
    baseUrl: String!

    """
    此LLM支持调用的模型列表
    """
    models: [String!]
    
    """
    Embedder供应商类型：
    规则: 分为两类: worker 或者 3rd_party
    """
    provider: String

    type: String
    creationTimestamp: Time
    updateTimestamp: Time
    status: String
    message: String
}

input CreateEmbedderInput {
    """模型服务资源名称（不可同名）"""
    name: String!
    """模型服务创建命名空间"""
    namespace: String!
    """模型服务资源标签"""
    labels: Map
    """模型服务资源注释"""
    annotations: Map
    """模型服务资源展示名称作为显示，并提供编辑"""
    displayName: String
    
    """模型服务资源描述"""
    description: String

    """模型服务访问信息(必填)"""
    endpointinput: EndpointInput!

    """
    向量化模型服务接口类型
    规则:  目前支持 zhipuai,openai两种接口类型
    """
    type: String
}

input UpdateEmbedderInput {
    """待修改模型服务资源名称(必填)"""
    name: String!
    """待修改模型服务创建命名空间(必填)"""
    namespace: String!

    """模型服务资源标签"""
    labels: Map
    """模型服务资源注释"""
    annotations: Map

    """模型服务资源展示名称作为显示，并提供编辑"""
    displayName: String
    """模型服务资源描述"""
    description: String

    """模型服务访问信息"""
    endpointinput: EndpointInput

    """
    向量化模型服务接口类型
    规则:  目前支持 zhipuai,openai两种接口类型
    """
    type: String
}

type EmbedderQuery {
    getEmbedder(name: String!, namespace: String!): Embedder!
    listEmbedders(input: ListCommonInput!): PaginatedResult!
}

type EmbedderMutation {
    createEmbedder(input: CreateEmbedderInput!): Embedder!
    updateEmbedder(input: UpdateEmbedderInput): Embedder!
    deleteEmbedders(input: DeleteCommonInput): Void
}
# mutation
extend type Mutation {
    Embedder: EmbedderMutation
}
# query
extend type Query{
    Embedder: EmbedderQuery
}
`, BuiltIn: false},
	{Name: "../schema/entrypoint.graphqls", Input: `type Query {
    hello(name: String!): String!
}
type Mutation{
    hello(name: String!): String!
}

"""对象存储终端输入"""
input EndpointInput {
    """地址(必填)"""
    url: String!
    """secret验证密码"""
    auth: Map
    """默认true"""
    insecure: Boolean
}

input ListCommonInput {
    namespace: String!

    """
    关键词: 模糊匹配
    """
    keyword: String

    """标签选择器"""
    labelSelector: String
    """字段选择器"""
    fieldSelector: String
    """
    分页页码，
    规则: 从1开始，默认是1
    """
    page: Int

    """
    每页数量，
    规则: 默认10
    """
    pageSize: Int
}

input DeleteCommonInput {
    name: String
    namespace: String!
    """标签选择器"""
    labelSelector: String
    """字段选择器"""
    fieldSelector: String
}

scalar Time
scalar Map
scalar Void

type PaginatedResult {
    hasNextPage: Boolean!
    nodes: [PageNode!]
    page: Int
    pageSize: Int
    totalCount: Int!
}

input TypedObjectReferenceInput {
    apiGroup: String
    kind: String!
    name: String!
    namespace: String
}

type TypedObjectReference {
    apiGroup: String
    kind: String!
    name: String!
    namespace: String
}

union PageNode = Datasource | Model | Embedder | KnowledgeBase | Dataset | VersionedDataset | F | Worker | ApplicationMetadata | LLM | ModelService
`, BuiltIn: false},
	{Name: "../schema/knowledgebase.graphqls", Input: `"""
文件组
规则: 属于同一个源(数据集)的文件要放在同一个filegroup中
规则: path直接读取文件里表中的文件路径即可
"""
type filegroup{
    """
    源；目前仅支持版本数据集，即 Kind为 VersionedDataset
    """
    source: TypedObjectReference
    """
    路径数组
    """
    path: [String!]
}

"""
文件详情
描述: 文件在知识库中的详细状态
"""
type filedetail{
    """文件路径"""
    path: String!

    """
    文件类型
    规则: enum { QA }
    """
    fileType: String!

    """
    文件中的数据条目总数
    """
    count: String!
    
    """
    文件大小
    """
    size: String!

    """
    最新处理时间
    """
    updateTimestamp: Time

    """
    文件处理的阶段
    规则: enum { Pending , Processing , Succeeded, Failed, Skipped}
    """
    phase: String!
}

"""
文件组详情
描述: 文件组在知识库中的状态
"""
type filegroupdetail{
    """
    源；目前仅支持版本数据集，即 Kind为 VersionedDataset
    """
    source: TypedObjectReference

    """
    文件详情
    规则；数组。具体文件详情参考 filedetail描述
    """
    filedetails:[filedetail]
}

"""
知识库
"""
type KnowledgeBase {
    """
    知识库id,为CR资源中的metadata.uid
    """
    id: String

    """
    名称
    规则: 遵循k8s命名
    """
    name: String!

    """
    所在的namespace(文件上传时作为bucket)
    规则: 获取当前项目对应的命名空间
    规则: 非空
    """
    namespace: String!

    """一些用于标记，选择的的标签"""
    labels: Map
    """添加一些辅助性记录信息"""
    annotations: Map
    

    """
    创建者，为当前用户的用户名
    规则: webhook启用后自动添加，默认为空
    """
    creator: String

    """展示名"""
    displayName: String

    """描述信息"""
    description: String

    """创建时间"""
    creationTimestamp: Time
    """更新时间"""
    updateTimestamp: Time
    
    """
    embedder指当前知识库使用的embedding向量化模型，即 Kind 为 Embedder
    """
    embedder: TypedObjectReference
    """
    vectorStore指当前知识库使用的向量数据库服务，即 Kind 为 VectorStore
    """
    vectorStore: TypedObjectReference
    """
    fileGroupDetails为知识库中所处理的文件组的详细内容和状态
    """
    fileGroupDetails: [filegroupdetail]
    
    """
    知识库整体连接状态
    规则: True 代表正常 False代表异常  
    规则: Deleting 代表删除中
    """
    status: String
    """知识库状态的原因"""
    reason: String
    """知识库状态的原因的详细内容"""
    message: String
}

"""源文件输入"""
input filegroupinput {
    """数据源字段"""
    source: TypedObjectReferenceInput!
    """路径"""
    path: [String!]
}

"""创建知识库的输入"""
input CreateKnowledgeBaseInput{
    """知识库资源名称（不可同名）"""
    name: String!
    """知识库创建命名空间"""
    namespace: String!

    """知识库资源标签"""
    labels: Map
    """知识库资源注释"""
    annotations: Map

    """知识库资源展示名称作为显示，并提供编辑"""
    displayName: String
    """知识库资源描述"""
    description: String

     """
    embedder指当前知识库使用的embedding向量化模型
    """
    embedder: String!

    """"向量数据库(目前不需要填写，直接使用系统默认的向量数据库)"""
    vectorStore: TypedObjectReferenceInput
    """知识库文件"""
    fileGroups: [filegroupinput!]
}

"""知识库更新的输入"""
input UpdateKnowledgeBaseInput {
    """知识库资源名称（不可同名）"""
    name: String!
    """知识库创建命名空间"""
    namespace: String!
    """知识库资源标签"""
    labels: Map
    """知识库资源注释"""
    annotations: Map

    """如不更新，则为空"""
    displayName: String

    """如不更新，则为空"""
    description: String

    """更新知识库文件"""
    fileGroups: [filegroupinput!]
}

"""知识库分页列表查询的输入"""
input ListKnowledgeBaseInput {
    name: String
    namespace: String!

    displayName: String
    """标签选择器"""
    labelSelector: String
    """字段选择器"""
    fieldSelector: String

    """
    分页页码，
    规则: 从1开始，默认是1
    """
    page: Int

    """
    每页数量，
    规则: 默认10
    """
    pageSize: Int

    """
    关键词: 模糊匹配
    规则: name,displayName中如果包含该字段则返回
    """
    keyword: String
}

type KnowledgeBaseQuery {
    getKnowledgeBase(name: String!, namespace: String!): KnowledgeBase!
    listKnowledgeBases(input: ListKnowledgeBaseInput!): PaginatedResult!
}

type KnowledgeBaseMutation {
    createKnowledgeBase(input: CreateKnowledgeBaseInput!): KnowledgeBase!
    updateKnowledgeBase(input: UpdateKnowledgeBaseInput): KnowledgeBase!
    deleteKnowledgeBase(input: DeleteCommonInput): Void
}

# mutation
extend type Mutation {
    KnowledgeBase: KnowledgeBaseMutation
}
# query
extend type Query{
    KnowledgeBase: KnowledgeBaseQuery
}
`, BuiltIn: false},
	{Name: "../schema/llm.graphqls", Input: `type LLM {
    id: String
    name: String!
    namespace: String!
    labels: Map
    annotations: Map
    creator: String
    displayName: String
    description: String

    """
    服务地址
    """
    baseUrl: String!

    """
    此LLM支持调用的模型列表
    """
    models: [String!]

    """
    LLM供应商类型：
    规则: 分为两类: worker 或者 3rd_party
    """
    provider: String

    type: String
    creationTimestamp: Time
    updateTimestamp: Time
    status: String
    message: String
}

input CreateLLMInput {
     """模型服务资源名称（不可同名）"""
    name: String!
    """模型服务创建命名空间"""
    namespace: String!
    """模型服务资源标签"""
    labels: Map
    """模型服务资源注释"""
    annotations: Map
    """模型服务资源展示名称作为显示，并提供编辑"""
    displayName: String
    
    """模型服务资源描述"""
    description: String

    """模型服务访问信息(必填)"""
    endpointinput: EndpointInput!

    """
    模型服务接口类型
    规则:  目前支持 zhipuai,openai两种接口类型
    """
    type: String
}

input UpdateLLMInput {
    """待修改模型服务资源名称(必填)"""
    name: String!
    """待修改模型服务创建命名空间(必填)"""
    namespace: String!
    """模型服务资源标签"""
    labels: Map
    """模型服务资源注释"""
    annotations: Map
    """模型服务资源展示名称作为显示，并提供编辑"""
    displayName: String

    """模型服务资源描述"""
    description: String

    """模型服务访问信息"""
    endpointinput: EndpointInput

    """
    模型服务接口类型
    规则:  目前支持 zhipuai,openai两种接口类型
    """
    type: String
}

type LLMQuery {
    getLLM(name: String!, namespace: String!): LLM!
    listLLMs(input: ListCommonInput!): PaginatedResult!
}

# query
extend type Query{
    LLM: LLMQuery
}`, BuiltIn: false},
	{Name: "../schema/model.graphqls", Input: `"""模型"""
type Model {
    """
    模型id,为CR资源中的metadata.uid
    """
    id: String

    """
    名称
    规则: 遵循k8s命名
    """
    name: String!

    """
    所在的namespace(文件上传时作为bucket)
    规则: 获取当前项目对应的命名空间
    规则: 非空
    """
    namespace: String!

    """
    模型是否是由系统提供
    规则: 如果为true，则是系统系统的。
    规则: 如果是系统提供的模型，不允许修改
    """
    systemModel: Boolean

    """一些用于标记，选择的的标签"""
    labels: Map
    """添加一些辅助性记录信息"""
    annotations: Map

    """
    创建者，为当前用户的用户名
    规则: webhook启用后自动添加，默认为空
    """
    creator: String

    """展示名"""
    displayName: String

    """描述信息"""
    description: String

    """创建时间"""
    creationTimestamp: Time
    """更新时间"""
    updateTimestamp: Time

    """
    模型类型
    规则: 目前支持 llm和embedding两种模型类型
    规则: 如果该模型支持多种模型类型，则可多选。多选后组成的字段通过逗号隔开。如 "llm,embedding"
    """
    types: String!

    """
    状态
    """
    status: String

    """
    详细信息
    """
    message: String

    """
    模型包含文件列表
    """
    files(input: FileFilter): PaginatedResult!
}

"""创建模型的输入"""
input CreateModelInput{
    """模型资源名称（不可同名）"""
    name: String!
    """模型创建命名空间"""
    namespace: String!

    """模型资源展示名称作为显示，并提供编辑"""
    displayName: String
    """模型资源描述"""
    description: String

    """
    模型类型
    规则: 目前支持 llm和embedding两种模型类型
    规则: 如果该模型支持多种模型类型，则可多选。多选后组成的字段通过逗号隔开。如 "llm,embedding"
    """
    types: String!
}

"""模型更新的输入"""
input UpdateModelInput {
    """模型资源名称（不可同名）"""
    name: String!
    """模型创建命名空间"""
    namespace: String!

    """模型资标签"""
    labels: Map
    """模型资源注释"""
    annotations: Map
    """模型资源展示名称作为显示，并提供编辑"""
    displayName: String
    """模型资源描述"""
    description: String

    """
    模型类型
    规则: 目前支持 llm和embedding两种模型类型
    规则: 如果该模型支持多种模型类型，则可多选。多选后组成的字段通过逗号隔开。如 "llm,embedding"
    """
    types: String
}

type ModelMutation {
    createModel(input: CreateModelInput!): Model!
    updateModel(input: UpdateModelInput): Model!
    deleteModels(input: DeleteCommonInput): Void
}

input ListModelInput {
    namespace: String!

    """
    是否包含系统提供的模型
    规则: 为true时，代表将同时获取系统提供的模型
    规则: 默认为false
    """
    systemModel: Boolean

    """
    关键词: 模糊匹配
    """
    keyword: String

    """标签选择器"""
    labelSelector: String
    """字段选择器"""
    fieldSelector: String
    """
    分页页码，
    规则: 从1开始，默认是1
    """
    page: Int

    """
    每页数量，
    规则: 默认10
    """
    pageSize: Int
}

type ModelQuery {
    getModel(name: String!, namespace: String!): Model!
    listModels(input: ListModelInput!): PaginatedResult!
}

extend type Mutation {
    Model: ModelMutation
}

extend type Query {
    Model: ModelQuery
}
`, BuiltIn: false},
	{Name: "../schema/modelservice.graphqls", Input: `type ModelService {
    id: String
    name: String!
    namespace: String!

    labels: Map
    annotations: Map
    
    creator: String
    displayName: String
    description: String

    """
    模型服务的创建和更新时间
    """
    creationTimestamp: Time
    updateTimestamp: Time


    """
    模型服务供应商的类型
    规则: 3rd_party 第三方
    规则: worker 本地
    """
    providerType: String


    """
    模型服务能力类型，支持 llm 和 embedding 两种模型类型
    规则: 如果该模型支持多种模型类型，则可多选。多选后组成的字段通过逗号隔开。如 "llm,embedding"
    """
    types: String

    """
    模型服务 API 类型
    规则：支持 openai, zhipuai 两种类型
    """
    apiType: String


    """
    模型服务的大语言模型列表
    规则；如果不填或者为空，则按照模型的API类型获取默认的模型列表
    """
    llmModels: [String!]

    """
    模型服务的Embedding模型列表
    规则；如果不填或者为空，则按照模型的API类型获取默认的模型列表
    """
    embeddingModels: [String!]

    """
    服务地址: 仅针对第三方模型服务
    """
    baseUrl: String!

    """
    状态
    规则: 目前分为六种状态
      - True: 正常 (第三方模型服务)
      - False: 异常 (第三方模型服务)
      - Unknown: 未知 (本地模型服务)
      - Pending: 发布中 (本地模型服务)
      - Running: 已发布 (本地模型服务)
      - Error: 异常 (本地模型服务)
    """
    status: String

    """详细的状态消息描述"""
    message: String
}

input CreateModelServiceInput {
    """模型服务资源名称（不可同名）"""
    name: String!
    """模型服务创建命名空间"""
    namespace: String!

    """模型资源标签"""
    labels: Map
    """模型资源注释"""
    annotations: Map
    """模型资源展示名称作为显示，并提供编辑"""
    displayName: String
    """模型资源描述"""
    description: String

    """
    模型服务能力类型，支持 llm 和 embedding 两种模型类型
    规则: 如果该模型支持多种模型类型，则可多选。多选后组成的字段通过逗号隔开。如 "llm,embedding"
    """
    types: String

    """
    模型服务 API 类型
    规则：支持 openai, zhipuai 两种类型
    """
    apiType: String

    """
    模型服务终端输入
    """
    endpoint: EndpointInput!


    """
    模型服务的大语言模型列表
    规则；如果不填或者为空，则按照模型的API类型获取默认的模型列表
    """
    llmModels: [String!]

    """
    模型服务的Embedding模型列表
    规则；如果不填或者为空，则按照模型的API类型获取默认的模型列表
    """
    embeddingModels: [String!]
}

input UpdateModelServiceInput {
    """模型资源名称（不可同名）"""
    name: String!
    """模型创建命名空间"""
    namespace: String!

    """模型资标签"""
    labels: Map
    """模型资源注释"""
    annotations: Map
    """模型资源展示名称作为显示，并提供编辑"""
    displayName: String
    """模型资源描述"""
    description: String

    """
    模型服务能力类型，支持 llm 和 embedding 两种模型类型
    规则: 如果该模型支持多种模型类型，则可多选。多选后组成的字段通过逗号隔开。如 "llm,embedding"
    """
    types: String

    """
    模型服务 API 类型
    规则：支持 openai, zhipuai 两种类型
    """
    apiType: String

    """
    模型服务终端输入
    """
    endpoint: EndpointInput!

    """
    模型服务的大语言模型列表
    规则；如果不填或者为空，则按照模型的API类型获取默认的模型列表
    """
    llmModels: [String!]

    """
    模型服务的Embedding模型列表
    规则；如果不填或者为空，则按照模型的API类型获取默认的模型列表
    """
    embeddingModels: [String!]
}

input ListModelServiceInput {
    """
    关键词搜索
    """
    keyword: String
    namespace: String!
    page: Int
    pageSize: Int

    """
    模型服务的类型
    规则: 
        - 为空默认不过滤
        - llm 则仅返回LLM模型服务
        - embedding 则仅返回Embedding模型服务
        - llm,embedding 则返回同时提供LLM和Embedding能力的模型服务
    """
    types: String

    """
    模型服务供应商类型
    规则: 
        - 为空默认不过滤
        - worker 则仅返回本地模型服务
        - 3rd_party 则仅返回第三方模型服务
    """
    providerType: String

    """
    模型服务供应商类型
    规则: 
        - 为空默认不过滤
        - openai 则仅返回接口类型类型为openai的模型服务
        - zhipuai 则仅返回接口类型类型为zhipuai的模型服务
    """
    apiType: String
}

type ModelServiceMutation {
    createModelService(input: CreateModelServiceInput!): ModelService!
    updateModelService(input: UpdateModelServiceInput): ModelService!
    deleteModelService(input: DeleteCommonInput): Void
}

extend type Mutation {
    ModelService: ModelServiceMutation
}

type ModelServiceQuery {
    getModelService(name: String!, namespace: String!): ModelService!
    listModelServices(input: ListModelServiceInput): PaginatedResult!
    checkModelService(input: CreateModelServiceInput!): ModelService!
}

extend type Query {
    ModelService: ModelServiceQuery
}
`, BuiltIn: false},
	{Name: "../schema/versioned_dataset.graphqls", Input: `scalar Int64
"""
VersionedDataset
数据集的版本信息。
主要记录版本名字，数据的来源，以及文件的同步状态
"""
type VersionedDataset {
    """
    版本数据集id,为CR资源中的metadata.uid
    """
    id: String

    """数据集名称, 这个应该是前端随机生成就可以，没有实际用途"""
    name: String!

    """数据集所在的namespace，也是后续桶的名字"""
    namespace: String!

    """一些用于标记，选择的的标签"""
    labels: Map

    """添加一些辅助性记录信息"""
    annotations: Map

    """创建者，正查给你这个字段是不需要人写的，自动添加"""
    creator: String

    """展示名字， 与metadat.name不一样，这个展示名字是可以用中文的"""
    displayName: String

    """描述"""
    description: String

    """所属的数据集"""
    dataset: TypedObjectReference!

    """更新时间, 这里更新指文件同步，或者数据处理完成后，做的更新操作的时间"""
    updateTimestamp: Time
    creationTimestamp: Time!

    """数据集所包含的文件，对于文件需要支持过滤和分页"""
    files(input: FileFilter): PaginatedResult!

    
    """版本名称"""
    version: String!

    """该版本是否已经发布, 0是未发布，1是已经发布"""
    released: Int!
    
    """文件的同步状态, Processing或者'' 表示文件正在同步，Succeede 文件同步成功，Failed 存在文件同步失败"""
    syncStatus: String

    """数据处理状态，如果为空，表示还没有开始，processing 处理中，process_fail处理失败，process_complete处理完成"""
    dataProcessStatus: String
}

"""
File
展示某个版本的所有文件。
"""
type F {
    "文件在数据源中的路径，a/b/c.txt或者d.txt"
    path: String!

    """文件类型"""
    fileType: String!

    """数据量"""
    count: String

    """文件更新时间，如果没有导入成功，这个字段为空"""
    time: Time

    """文件大小"""
    size: String

    """文件创建时间"""
    creationTimestamp: Time    
}

"""
根据条件顾虑版本内的文件，只支持关键词搜索
"""
input FileFilter {
    """根据关键词搜索文件，strings.Container(fileName, keyword)"""
    keyword: String

    """页"""
    page: Int

    """页内容数量"""
    pageSize: Int

    """根据文件名字或者更新时间排序, file, time"""
    sortBy: String
}

input FileGroup {
    """数据源的基础信息"""
    source: TypedObjectReferenceInput! 

    """用到的文件路径，注意⚠️ 一定不要加bucket的名字"""
    paths: [String!]
}


input CreateVersionedDatasetInput {
    """数据集的CR名字，要满足k8s的名称规则"""
    name: String!

    namespace: String!

    """dataset的名字，需要根据这个名字，
    判断是否最新版本不包含任何文件(产品要求，有一个不包含任何文件的版本，不允许创建新的版本)
    """
    datasetName: String!

    """一些标签选择信息，可以不添加"""
    labels: Map

    """一些备注用的注视信息，或者记录一个简单的配置"""
    annotations: Map

    """展示名称，用于展示在界面上的，必须填写"""
    displayName: String
    
    """描述信息，可以不写"""
    description: String

    """数据集里面的数据的类型，文本，视频，图片"""
    version: String!

    """是否发布，0是未发布，1是已经发布，创建一个版本的时候默认传递0就可以"""
    released: Int!

    """从数据源要上传的文件，目前以及不用了"""
    fileGrups: [FileGroup]

    """界面上创建新版本选择从某个版本集成的时候，填写version字段"""
    inheritedFrom: String
}

input UpdateVersionedDatasetInput {
    """
    这个名字就是metadat.name, 根据name和namespace确定资源
    name，namespac是不可以更新的。
    """
    name: String!
    namespace: String!

    """
    更新的的标签信息，这里涉及到增加或者删除标签，
    所以，如果标签有任何改动，传递完整的label。
    例如之前的标齐是: abc:def 新增一个标签aa:bb, 那么传递 abc:def, aa:bb
    """
    labels: Map

    """传递方式同label"""
    annotations: Map
    
    displayName: String
    description: String

    """
    更新，删除数据集版本中的文件，传递方式于label相同，完全传递。
    如果传递一个空的数组过去，认为是删除全部文件。
    """
    fileGroups: [FileGroup!]

    """修改数据集版本发布状态"""
    released: Int
}


input DeleteVersionedDatasetInput {
    name: String
    namespace: String!
    labelSelector: String
    fieldSelector: String
}

input ListVersionedDatasetInput {
    name: String
    namespace: String
    displayName: String
    labelSelector: String
    fieldSelector: String

    """分页页码，从1开始，默认是1"""
    page: Int

    """每页数量，默认10"""
    pageSize: Int
    keyword: String
}

type VersionedDatasetQuery {
    getVersionedDataset(name: String!, namespace: String!): VersionedDataset!
    listVersionedDatasets(input: ListVersionedDatasetInput!): PaginatedResult! 
}
type VersionedDatasetMutation {
    createVersionedDataset(input: CreateVersionedDatasetInput!): VersionedDataset! 
    updateVersionedDataset(input: UpdateVersionedDatasetInput!): VersionedDataset!
    deleteVersionedDatasets(input: DeleteVersionedDatasetInput!): Void
}

extend type Query {
    VersionedDataset: VersionedDatasetQuery
}

extend type Mutation {
    VersionedDataset: VersionedDatasetMutation
}
`, BuiltIn: false},
	{Name: "../schema/worker.graphqls", Input: `"""模型服务worker节点的资源(limits)"""
type Resources {
    cpu: String
    memory: String
    nvidiaGPU: String
}

"""资源配置的输入"""
input ResourcesInput {
    """
    cpu配置
    规则: 必填
    """
    cpu: String!
    """
    memory配置
    规则: 必填
    """
    memory: String!
    """
    gpu配置
    """
    nvidiaGPU: String
}

"""本地模型服务节点"""
type Worker {
    """
    模型id,为CR资源中的metadata.uid
    """
    id: String

    """
    名称
    规则: 遵循k8s命名
    """
    name: String!

    """
    所在的namespace(文件上传时作为bucket)
    规则: 获取当前项目对应的命名空间
    规则: 非空
    """
    namespace: String!

    """一些用于标记，选择的的标签"""
    labels: Map
    """添加一些辅助性记录信息"""
    annotations: Map

    """
    创建者，为当前用户的用户名
    规则: webhook启用后自动添加，默认为空
    """
    creator: String

    """展示名"""
    displayName: String

    """描述信息"""
    description: String

    """创建时间"""
    creationTimestamp: Time
    """更新时间"""
    updateTimestamp: Time

    """
    Worker类型
    支持两种类型: 
    - "fastchat" : fastchat提供的通用的推理服务模式
    - "fastchat-vllm" : fastchat提供的采用VLLM推理加速的推理服务模式
    规则: 如果为空，则默认为 "fastchat"
    """
    type: String

    """
    worker对应的模型
    规则: 相同namespace下的模型名称
    规则: 必填
    """
    model: TypedObjectReference!

    """
    worker对应的模型类型
    """
    modelTypes: String!

    """
    worker运行的Pod副本数量
    规则: 默认为1，最大值为1
    规则: 为0时，即下线
    """
    replicas: String

    """
    worker运行所需的资源
    规则: 必填
    """
    resources: Resources!

    """
    状态
    规则: 目前分为四种状态
      - Unknown: 未知
      - Pending: 发布中
      - Running: 已发布
      - Error: 异常
    """
    status: String

    """详细的状态消息描述"""
    message: String

    """模型服务的api地址"""
    api: String
}

"""创建模型服务worker的输入"""
input CreateWorkerInput{
    """模型资源名称（不可同名）"""
    name: String!
    """模型创建命名空间"""
    namespace: String!

    """模型资源展示名称作为显示，并提供编辑"""
    displayName: String
    """模型资源描述"""
    description: String

    """
    Worker类型
    支持两种类型: 
    - "fastchat" : fastchat提供的通用的推理服务模式
    - "fastchat-vllm" : fastchat提供的采用VLLM推理加速的推理服务模式
    规则: 如果为空，则默认为 "fastchat"
    """
    type: String

    """
    worker对应的模型
    规则: 必须指定模型准确的namespace
    规则: 必填
    """
    model: TypedObjectReferenceInput!

    """
    worker运行所需的资源
    规则: 必填
    """
    resources: ResourcesInput!
}

"""模型更新的输入"""
input UpdateWorkerInput {
    """模型资源名称（不可同名）"""
    name: String!
    """模型创建命名空间"""
    namespace: String!

    """模型资标签"""
    labels: Map
    """模型资源注释"""
    annotations: Map
    
    """模型资源展示名称作为显示，并提供编辑"""
    displayName: String
    """模型资源描述"""
    description: String

    """
    Worker类型
    支持两种类型: 
    - "fastchat" : fastchat提供的通用的推理服务模式
    - "fastchat-vllm" : fastchat提供的采用VLLM推理加速的推理服务模式
    规则: 如果为空，则不更新；如果type类型与当前类型相同，则不更新
    """
    type: String

    replicas: String

    """
    worker运行所需的资源
    """
    resources: ResourcesInput
}

input ListWorkerInput {
    namespace: String!

    """
    关键词: 模糊匹配
    """
    keyword: String

    """标签选择器"""
    labelSelector: String
    """字段选择器"""
    fieldSelector: String
    """
    分页页码，
    规则: 从1开始，默认是1
    """
    page: Int

    """
    每页数量，
    规则: 默认10
    """
    pageSize: Int

    """
    worker对应的模型类型
    规则: 模型分为embedding和llm两大类。如果两者都有，则通过逗号隔开，如: "embedding,llm"
    """
    modelTypes: String
}

type WorkerMutation {
    createWorker(input: CreateWorkerInput!): Worker!
    updateWorker(input: UpdateWorkerInput): Worker!
    deleteWorkers(input: DeleteCommonInput): Void
}

type WorkerQuery {
    getWorker(name: String!, namespace: String!): Worker!
    listWorkers(input: ListWorkerInput!): PaginatedResult!
}

extend type Mutation {
    Worker: WorkerMutation
}

extend type Query {
    Worker: WorkerQuery
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_ApplicationMutation_createApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateApplicationMetadataInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateApplicationMetadataInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateApplicationMetadataInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ApplicationMutation_deleteApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeleteCommonInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ApplicationMutation_updateApplicationConfig_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 UpdateApplicationConfigInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateApplicationConfigInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateApplicationConfigInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ApplicationMutation_updateApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 UpdateApplicationMetadataInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateApplicationMetadataInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateApplicationMetadataInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ApplicationQuery_getApplication_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_ApplicationQuery_listApplicationMetadata_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListCommonInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessMutation_createDataProcessTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AddDataProcessInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOAddDataProcessInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐAddDataProcessInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessMutation_deleteDataProcessTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteDataProcessInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteDataProcessInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteDataProcessInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_allDataProcessListByCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AllDataProcessListByCountInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOAllDataProcessListByCountInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐAllDataProcessListByCountInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_allDataProcessListByPage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AllDataProcessListByPageInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOAllDataProcessListByPageInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐAllDataProcessListByPageInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_checkDataProcessTaskName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CheckDataProcessTaskNameInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCheckDataProcessTaskNameInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCheckDataProcessTaskNameInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DataProcessQuery_dataProcessDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DataProcessDetailsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODataProcessDetailsInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessDetailsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetMutation_createDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CreateDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCreateDatasetInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetMutation_deleteDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetMutation_updateDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateDatasetInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetQuery_getDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_DatasetQuery_listDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ListDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOListDatasetInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Dataset_versions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListVersionedDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListVersionedDatasetInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListVersionedDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasourceMutation_createDatasource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateDatasourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateDatasourceInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateDatasourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasourceMutation_deleteDatasources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasourceMutation_updateDatasource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateDatasourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateDatasourceInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateDatasourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasourceQuery_checkDatasource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateDatasourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateDatasourceInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateDatasourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasourceQuery_getDatasource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_DatasourceQuery_listDatasources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListCommonInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_EmbedderMutation_createEmbedder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateEmbedderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateEmbedderInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateEmbedderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_EmbedderMutation_deleteEmbedders_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_EmbedderMutation_updateEmbedder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateEmbedderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateEmbedderInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateEmbedderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_EmbedderQuery_getEmbedder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_EmbedderQuery_listEmbedders_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListCommonInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_KnowledgeBaseMutation_createKnowledgeBase_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateKnowledgeBaseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateKnowledgeBaseInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateKnowledgeBaseInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_KnowledgeBaseMutation_deleteKnowledgeBase_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_KnowledgeBaseMutation_updateKnowledgeBase_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateKnowledgeBaseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateKnowledgeBaseInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateKnowledgeBaseInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_KnowledgeBaseQuery_getKnowledgeBase_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_KnowledgeBaseQuery_listKnowledgeBases_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListKnowledgeBaseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListKnowledgeBaseInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListKnowledgeBaseInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_LLMQuery_getLLM_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_LLMQuery_listLLMs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListCommonInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelMutation_createModel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateModelInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateModelInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateModelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelMutation_deleteModels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelMutation_updateModel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateModelInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateModelInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateModelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelQuery_getModel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_ModelQuery_listModels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListModelInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListModelInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListModelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelServiceMutation_createModelService_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateModelServiceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateModelServiceInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateModelServiceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelServiceMutation_deleteModelService_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelServiceMutation_updateModelService_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateModelServiceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateModelServiceInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateModelServiceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelServiceQuery_checkModelService_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateModelServiceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateModelServiceInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateModelServiceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ModelServiceQuery_getModelService_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_ModelServiceQuery_listModelServices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ListModelServiceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOListModelServiceInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListModelServiceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Model_files_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *FileFilter
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOFileFilter2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_hello_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hello_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_VersionedDatasetMutation_createVersionedDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateVersionedDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateVersionedDatasetInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateVersionedDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_VersionedDatasetMutation_deleteVersionedDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 DeleteVersionedDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeleteVersionedDatasetInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteVersionedDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_VersionedDatasetMutation_updateVersionedDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 UpdateVersionedDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateVersionedDatasetInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateVersionedDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_VersionedDatasetQuery_getVersionedDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_VersionedDatasetQuery_listVersionedDatasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListVersionedDatasetInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListVersionedDatasetInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListVersionedDatasetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_VersionedDataset_files_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *FileFilter
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOFileFilter2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_WorkerMutation_createWorker_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateWorkerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateWorkerInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateWorkerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_WorkerMutation_deleteWorkers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteCommonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteCommonInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteCommonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_WorkerMutation_updateWorker_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateWorkerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateWorkerInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateWorkerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_WorkerQuery_getWorker_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["namespace"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["namespace"] = arg1
	return args, nil
}

func (ec *executionContext) field_WorkerQuery_listWorkers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ListWorkerInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNListWorkerInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListWorkerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Application_metadata(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationMetadata)
	fc.Result = res
	return ec.marshalOApplicationMetadata2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplicationMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ApplicationMetadata_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ApplicationMetadata_namespace(ctx, field)
			case "id":
				return ec.fieldContext_ApplicationMetadata_id(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationMetadata_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ApplicationMetadata_annotations(ctx, field)
			case "displayName":
				return ec.fieldContext_ApplicationMetadata_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationMetadata_description(ctx, field)
			case "icon":
				return ec.fieldContext_ApplicationMetadata_icon(ctx, field)
			case "creator":
				return ec.fieldContext_ApplicationMetadata_creator(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ApplicationMetadata_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ApplicationMetadata_updateTimestamp(ctx, field)
			case "isPublic":
				return ec.fieldContext_ApplicationMetadata_isPublic(ctx, field)
			case "status":
				return ec.fieldContext_ApplicationMetadata_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_prologue(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_prologue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prologue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_prologue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_model(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_llm(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_llm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Llm, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_llm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_temperature(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_temperature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Temperature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_temperature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_maxLength(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_maxLength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxLength, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_maxLength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_conversionWindowSize(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_conversionWindowSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConversionWindowSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_conversionWindowSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_knowledgebase(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_knowledgebase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Knowledgebase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_knowledgebase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_scoreThreshold(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_scoreThreshold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScoreThreshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_scoreThreshold(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_numDocuments(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_numDocuments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDocuments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_numDocuments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_docNullReturn(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_docNullReturn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocNullReturn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_docNullReturn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_userPrompt(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_userPrompt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserPrompt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_userPrompt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Application_showNextGuid(ctx context.Context, field graphql.CollectedField, obj *Application) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Application_showNextGuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowNextGUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Application_showNextGuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_name(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_namespace(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_id(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_labels(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_annotations(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_description(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_icon(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_icon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Icon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_icon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_creator(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_isPublic(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_isPublic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPublic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_isPublic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMetadata_status(ctx context.Context, field graphql.CollectedField, obj *ApplicationMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMetadata_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMetadata_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMutation_createApplication(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMutation_createApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationMutation().CreateApplication(rctx, obj, fc.Args["input"].(CreateApplicationMetadataInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationMetadata)
	fc.Result = res
	return ec.marshalNApplicationMetadata2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplicationMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMutation_createApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ApplicationMetadata_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ApplicationMetadata_namespace(ctx, field)
			case "id":
				return ec.fieldContext_ApplicationMetadata_id(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationMetadata_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ApplicationMetadata_annotations(ctx, field)
			case "displayName":
				return ec.fieldContext_ApplicationMetadata_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationMetadata_description(ctx, field)
			case "icon":
				return ec.fieldContext_ApplicationMetadata_icon(ctx, field)
			case "creator":
				return ec.fieldContext_ApplicationMetadata_creator(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ApplicationMetadata_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ApplicationMetadata_updateTimestamp(ctx, field)
			case "isPublic":
				return ec.fieldContext_ApplicationMetadata_isPublic(ctx, field)
			case "status":
				return ec.fieldContext_ApplicationMetadata_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationMetadata", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationMutation_createApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMutation_updateApplication(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMutation_updateApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationMutation().UpdateApplication(rctx, obj, fc.Args["input"].(UpdateApplicationMetadataInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ApplicationMetadata)
	fc.Result = res
	return ec.marshalNApplicationMetadata2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplicationMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMutation_updateApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ApplicationMetadata_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ApplicationMetadata_namespace(ctx, field)
			case "id":
				return ec.fieldContext_ApplicationMetadata_id(ctx, field)
			case "labels":
				return ec.fieldContext_ApplicationMetadata_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ApplicationMetadata_annotations(ctx, field)
			case "displayName":
				return ec.fieldContext_ApplicationMetadata_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ApplicationMetadata_description(ctx, field)
			case "icon":
				return ec.fieldContext_ApplicationMetadata_icon(ctx, field)
			case "creator":
				return ec.fieldContext_ApplicationMetadata_creator(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ApplicationMetadata_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ApplicationMetadata_updateTimestamp(ctx, field)
			case "isPublic":
				return ec.fieldContext_ApplicationMetadata_isPublic(ctx, field)
			case "status":
				return ec.fieldContext_ApplicationMetadata_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationMetadata", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationMutation_updateApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMutation_deleteApplication(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMutation_deleteApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationMutation().DeleteApplication(rctx, obj, fc.Args["input"].(DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMutation_deleteApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationMutation_deleteApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationMutation_updateApplicationConfig(ctx context.Context, field graphql.CollectedField, obj *ApplicationMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationMutation_updateApplicationConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationMutation().UpdateApplicationConfig(rctx, obj, fc.Args["input"].(UpdateApplicationConfigInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationMutation_updateApplicationConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "metadata":
				return ec.fieldContext_Application_metadata(ctx, field)
			case "prologue":
				return ec.fieldContext_Application_prologue(ctx, field)
			case "model":
				return ec.fieldContext_Application_model(ctx, field)
			case "llm":
				return ec.fieldContext_Application_llm(ctx, field)
			case "temperature":
				return ec.fieldContext_Application_temperature(ctx, field)
			case "maxLength":
				return ec.fieldContext_Application_maxLength(ctx, field)
			case "conversionWindowSize":
				return ec.fieldContext_Application_conversionWindowSize(ctx, field)
			case "knowledgebase":
				return ec.fieldContext_Application_knowledgebase(ctx, field)
			case "scoreThreshold":
				return ec.fieldContext_Application_scoreThreshold(ctx, field)
			case "numDocuments":
				return ec.fieldContext_Application_numDocuments(ctx, field)
			case "docNullReturn":
				return ec.fieldContext_Application_docNullReturn(ctx, field)
			case "userPrompt":
				return ec.fieldContext_Application_userPrompt(ctx, field)
			case "showNextGuid":
				return ec.fieldContext_Application_showNextGuid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationMutation_updateApplicationConfig_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationQuery_getApplication(ctx context.Context, field graphql.CollectedField, obj *ApplicationQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationQuery_getApplication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationQuery().GetApplication(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Application)
	fc.Result = res
	return ec.marshalNApplication2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplication(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationQuery_getApplication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "metadata":
				return ec.fieldContext_Application_metadata(ctx, field)
			case "prologue":
				return ec.fieldContext_Application_prologue(ctx, field)
			case "model":
				return ec.fieldContext_Application_model(ctx, field)
			case "llm":
				return ec.fieldContext_Application_llm(ctx, field)
			case "temperature":
				return ec.fieldContext_Application_temperature(ctx, field)
			case "maxLength":
				return ec.fieldContext_Application_maxLength(ctx, field)
			case "conversionWindowSize":
				return ec.fieldContext_Application_conversionWindowSize(ctx, field)
			case "knowledgebase":
				return ec.fieldContext_Application_knowledgebase(ctx, field)
			case "scoreThreshold":
				return ec.fieldContext_Application_scoreThreshold(ctx, field)
			case "numDocuments":
				return ec.fieldContext_Application_numDocuments(ctx, field)
			case "docNullReturn":
				return ec.fieldContext_Application_docNullReturn(ctx, field)
			case "userPrompt":
				return ec.fieldContext_Application_userPrompt(ctx, field)
			case "showNextGuid":
				return ec.fieldContext_Application_showNextGuid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Application", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationQuery_getApplication_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ApplicationQuery_listApplicationMetadata(ctx context.Context, field graphql.CollectedField, obj *ApplicationQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApplicationQuery_listApplicationMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationQuery().ListApplicationMetadata(rctx, obj, fc.Args["input"].(ListCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApplicationQuery_listApplicationMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApplicationQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ApplicationQuery_listApplicationMetadata_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CountDataProcessItem_status(ctx context.Context, field graphql.CollectedField, obj *CountDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CountDataProcessItem_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CountDataProcessItem_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CountDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CountDataProcessItem_data(ctx context.Context, field graphql.CollectedField, obj *CountDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CountDataProcessItem_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CountDataProcessItem_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CountDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CountDataProcessItem_message(ctx context.Context, field graphql.CollectedField, obj *CountDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CountDataProcessItem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CountDataProcessItem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CountDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfig_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfig_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfig_description(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfig_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfig_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfig_file_num(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfig_file_num(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfig_file_num(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfig_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfig_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfig_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfig_children(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfig_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfigChildren)
	fc.Result = res
	return ec.marshalODataProcessConfigChildren2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigChildren(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfig_children(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_DataProcessConfigChildren_name(ctx, field)
			case "enable":
				return ec.fieldContext_DataProcessConfigChildren_enable(ctx, field)
			case "zh_name":
				return ec.fieldContext_DataProcessConfigChildren_zh_name(ctx, field)
			case "description":
				return ec.fieldContext_DataProcessConfigChildren_description(ctx, field)
			case "llm_config":
				return ec.fieldContext_DataProcessConfigChildren_llm_config(ctx, field)
			case "preview":
				return ec.fieldContext_DataProcessConfigChildren_preview(ctx, field)
			case "file_progress":
				return ec.fieldContext_DataProcessConfigChildren_file_progress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfigChildren", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_enable(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_enable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_enable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_zh_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_zh_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZhName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_zh_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_description(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_llm_config(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_llm_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LlmConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*LLMConfig)
	fc.Result = res
	return ec.marshalOLLMConfig2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐLLMConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_llm_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_LLMConfig_name(ctx, field)
			case "namespace":
				return ec.fieldContext_LLMConfig_namespace(ctx, field)
			case "model":
				return ec.fieldContext_LLMConfig_model(ctx, field)
			case "temperature":
				return ec.fieldContext_LLMConfig_temperature(ctx, field)
			case "top_p":
				return ec.fieldContext_LLMConfig_top_p(ctx, field)
			case "max_tokens":
				return ec.fieldContext_LLMConfig_max_tokens(ctx, field)
			case "prompt_template":
				return ec.fieldContext_LLMConfig_prompt_template(ctx, field)
			case "provider":
				return ec.fieldContext_LLMConfig_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LLMConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_preview(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_preview(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Preview, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfigpreView)
	fc.Result = res
	return ec.marshalODataProcessConfigpreView2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreView(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_preview(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "file_name":
				return ec.fieldContext_DataProcessConfigpreView_file_name(ctx, field)
			case "content":
				return ec.fieldContext_DataProcessConfigpreView_content(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfigpreView", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigChildren_file_progress(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigChildren_file_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileProgress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfigpreFileProgress)
	fc.Result = res
	return ec.marshalODataProcessConfigpreFileProgress2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreFileProgress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigChildren_file_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DataProcessConfigpreFileProgress_id(ctx, field)
			case "file_name":
				return ec.fieldContext_DataProcessConfigpreFileProgress_file_name(ctx, field)
			case "status":
				return ec.fieldContext_DataProcessConfigpreFileProgress_status(ctx, field)
			case "start_time":
				return ec.fieldContext_DataProcessConfigpreFileProgress_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_DataProcessConfigpreFileProgress_end_time(ctx, field)
			case "progress":
				return ec.fieldContext_DataProcessConfigpreFileProgress_progress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfigpreFileProgress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_id(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_file_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_file_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_file_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_start_time(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_end_time(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_end_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreFileProgress_progress(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreFileProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreFileProgress_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Progress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreFileProgress_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreFileProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreView_file_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreView) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreView_file_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreView_file_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreView",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreView_content(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreView) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreView_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfigpreViewContent)
	fc.Result = res
	return ec.marshalODataProcessConfigpreViewContent2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreViewContent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreView_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreView",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pre":
				return ec.fieldContext_DataProcessConfigpreViewContent_pre(ctx, field)
			case "post":
				return ec.fieldContext_DataProcessConfigpreViewContent_post(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfigpreViewContent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreViewContent_pre(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreViewContent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreViewContent_pre(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pre, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreViewContent_pre(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreViewContent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessConfigpreViewContent_post(ctx context.Context, field graphql.CollectedField, obj *DataProcessConfigpreViewContent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessConfigpreViewContent_post(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Post, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessConfigpreViewContent_post(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessConfigpreViewContent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetails_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetails_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetails_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetails_data(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetails_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DataProcessDetailsItem)
	fc.Result = res
	return ec.marshalNDataProcessDetailsItem2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessDetailsItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetails_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DataProcessDetailsItem_id(ctx, field)
			case "status":
				return ec.fieldContext_DataProcessDetailsItem_status(ctx, field)
			case "name":
				return ec.fieldContext_DataProcessDetailsItem_name(ctx, field)
			case "file_type":
				return ec.fieldContext_DataProcessDetailsItem_file_type(ctx, field)
			case "pre_dataset_name":
				return ec.fieldContext_DataProcessDetailsItem_pre_dataset_name(ctx, field)
			case "pre_dataset_version":
				return ec.fieldContext_DataProcessDetailsItem_pre_dataset_version(ctx, field)
			case "post_dataset_name":
				return ec.fieldContext_DataProcessDetailsItem_post_dataset_name(ctx, field)
			case "post_dataset_version":
				return ec.fieldContext_DataProcessDetailsItem_post_dataset_version(ctx, field)
			case "file_num":
				return ec.fieldContext_DataProcessDetailsItem_file_num(ctx, field)
			case "start_time":
				return ec.fieldContext_DataProcessDetailsItem_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_DataProcessDetailsItem_end_time(ctx, field)
			case "creator":
				return ec.fieldContext_DataProcessDetailsItem_creator(ctx, field)
			case "error_msg":
				return ec.fieldContext_DataProcessDetailsItem_error_msg(ctx, field)
			case "config":
				return ec.fieldContext_DataProcessDetailsItem_config(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessDetailsItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetails_message(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetails_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetails_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_id(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_file_type(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_file_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_file_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_pre_dataset_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_pre_dataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreDatasetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_pre_dataset_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_pre_dataset_version(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_pre_dataset_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreDatasetVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_pre_dataset_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_post_dataset_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_post_dataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostDatasetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_post_dataset_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_post_dataset_version(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_post_dataset_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostDatasetVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_post_dataset_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_file_num(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_file_num(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_file_num(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_start_time(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_end_time(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_end_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_creator(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_error_msg(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_error_msg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_error_msg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessDetailsItem_config(ctx context.Context, field graphql.CollectedField, obj *DataProcessDetailsItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessDetailsItem_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessConfig)
	fc.Result = res
	return ec.marshalODataProcessConfig2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessDetailsItem_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessDetailsItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_DataProcessConfig_name(ctx, field)
			case "description":
				return ec.fieldContext_DataProcessConfig_description(ctx, field)
			case "file_num":
				return ec.fieldContext_DataProcessConfig_file_num(ctx, field)
			case "status":
				return ec.fieldContext_DataProcessConfig_status(ctx, field)
			case "children":
				return ec.fieldContext_DataProcessConfig_children(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_id(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_pre_data_set_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_pre_data_set_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreDataSetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_pre_data_set_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_pre_data_set_version(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_pre_data_set_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreDataSetVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_pre_data_set_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_post_data_set_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_post_data_set_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostDataSetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_post_data_set_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_post_data_set_version(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_post_data_set_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostDataSetVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_post_data_set_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_start_datetime(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_start_datetime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDatetime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_start_datetime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessItem_error_msg(ctx context.Context, field graphql.CollectedField, obj *DataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessItem_error_msg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessItem_error_msg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessMutation_createDataProcessTask(ctx context.Context, field graphql.CollectedField, obj *DataProcessMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessMutation_createDataProcessTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessMutation().CreateDataProcessTask(rctx, obj, fc.Args["input"].(*AddDataProcessInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessResponse)
	fc.Result = res
	return ec.marshalODataProcessResponse2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessMutation_createDataProcessTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessResponse_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessResponse_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessResponse_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessMutation_createDataProcessTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessMutation_deleteDataProcessTask(ctx context.Context, field graphql.CollectedField, obj *DataProcessMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessMutation_deleteDataProcessTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessMutation().DeleteDataProcessTask(rctx, obj, fc.Args["input"].(*DeleteDataProcessInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessResponse)
	fc.Result = res
	return ec.marshalODataProcessResponse2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessMutation_deleteDataProcessTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessResponse_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessResponse_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessResponse_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessMutation_deleteDataProcessTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_allDataProcessListByPage(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_allDataProcessListByPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().AllDataProcessListByPage(rctx, obj, fc.Args["input"].(*AllDataProcessListByPageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PaginatedDataProcessItem)
	fc.Result = res
	return ec.marshalOPaginatedDataProcessItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedDataProcessItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_allDataProcessListByPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_PaginatedDataProcessItem_status(ctx, field)
			case "data":
				return ec.fieldContext_PaginatedDataProcessItem_data(ctx, field)
			case "message":
				return ec.fieldContext_PaginatedDataProcessItem_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedDataProcessItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_allDataProcessListByPage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_allDataProcessListByCount(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_allDataProcessListByCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().AllDataProcessListByCount(rctx, obj, fc.Args["input"].(*AllDataProcessListByCountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CountDataProcessItem)
	fc.Result = res
	return ec.marshalOCountDataProcessItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCountDataProcessItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_allDataProcessListByCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_CountDataProcessItem_status(ctx, field)
			case "data":
				return ec.fieldContext_CountDataProcessItem_data(ctx, field)
			case "message":
				return ec.fieldContext_CountDataProcessItem_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CountDataProcessItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_allDataProcessListByCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_dataProcessSupportType(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_dataProcessSupportType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().DataProcessSupportType(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessSupportType)
	fc.Result = res
	return ec.marshalODataProcessSupportType2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessSupportType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_dataProcessSupportType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessSupportType_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessSupportType_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessSupportType_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessSupportType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_dataProcessDetails(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_dataProcessDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().DataProcessDetails(rctx, obj, fc.Args["input"].(*DataProcessDetailsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessDetails)
	fc.Result = res
	return ec.marshalODataProcessDetails2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_dataProcessDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessDetails_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessDetails_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessDetails_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessDetails", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_dataProcessDetails_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessQuery_checkDataProcessTaskName(ctx context.Context, field graphql.CollectedField, obj *DataProcessQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessQuery_checkDataProcessTaskName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DataProcessQuery().CheckDataProcessTaskName(rctx, obj, fc.Args["input"].(*CheckDataProcessTaskNameInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessResponse)
	fc.Result = res
	return ec.marshalODataProcessResponse2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessQuery_checkDataProcessTaskName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_DataProcessResponse_status(ctx, field)
			case "data":
				return ec.fieldContext_DataProcessResponse_data(ctx, field)
			case "message":
				return ec.fieldContext_DataProcessResponse_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DataProcessQuery_checkDataProcessTaskName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessResponse_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessResponse_data(ctx context.Context, field graphql.CollectedField, obj *DataProcessResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessResponse_message(ctx context.Context, field graphql.CollectedField, obj *DataProcessResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessResponse_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessResponse_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportType_status(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportType_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportType_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportType_data(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportType_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessSupportTypeItem)
	fc.Result = res
	return ec.marshalODataProcessSupportTypeItem2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessSupportTypeItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportType_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_DataProcessSupportTypeItem_name(ctx, field)
			case "description":
				return ec.fieldContext_DataProcessSupportTypeItem_description(ctx, field)
			case "children":
				return ec.fieldContext_DataProcessSupportTypeItem_children(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessSupportTypeItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportType_message(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportType_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportType_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeChildren_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeChildren_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeChildren_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeChildren_zh_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeChildren_zh_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZhName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeChildren_zh_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeChildren_enable(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeChildren_enable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeChildren_enable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeChildren_description(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeChildren) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeChildren_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeChildren_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeChildren",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeItem_name(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeItem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeItem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeItem_description(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeItem_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeItem_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DataProcessSupportTypeItem_children(ctx context.Context, field graphql.CollectedField, obj *DataProcessSupportTypeItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DataProcessSupportTypeItem_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessSupportTypeChildren)
	fc.Result = res
	return ec.marshalODataProcessSupportTypeChildren2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessSupportTypeChildrenᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DataProcessSupportTypeItem_children(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DataProcessSupportTypeItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_DataProcessSupportTypeChildren_name(ctx, field)
			case "zh_name":
				return ec.fieldContext_DataProcessSupportTypeChildren_zh_name(ctx, field)
			case "enable":
				return ec.fieldContext_DataProcessSupportTypeChildren_enable(ctx, field)
			case "description":
				return ec.fieldContext_DataProcessSupportTypeChildren_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessSupportTypeChildren", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_name(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_namespace(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_labels(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_annotations(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_creator(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_displayName(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_description(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_contentType(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_contentType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_contentType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_field(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dataset_versions(ctx context.Context, field graphql.CollectedField, obj *Dataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dataset_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().Versions(rctx, obj, fc.Args["input"].(ListVersionedDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dataset_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Dataset_versions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasetMutation_createDataset(ctx context.Context, field graphql.CollectedField, obj *DatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasetMutation_createDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetMutation().CreateDataset(rctx, obj, fc.Args["input"].(*CreateDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Dataset)
	fc.Result = res
	return ec.marshalNDataset2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasetMutation_createDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Dataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Dataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Dataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Dataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Dataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Dataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Dataset_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Dataset_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Dataset_updateTimestamp(ctx, field)
			case "contentType":
				return ec.fieldContext_Dataset_contentType(ctx, field)
			case "field":
				return ec.fieldContext_Dataset_field(ctx, field)
			case "versions":
				return ec.fieldContext_Dataset_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasetMutation_createDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasetMutation_updateDataset(ctx context.Context, field graphql.CollectedField, obj *DatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasetMutation_updateDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetMutation().UpdateDataset(rctx, obj, fc.Args["input"].(*UpdateDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Dataset)
	fc.Result = res
	return ec.marshalNDataset2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasetMutation_updateDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Dataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Dataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Dataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Dataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Dataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Dataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Dataset_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Dataset_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Dataset_updateTimestamp(ctx, field)
			case "contentType":
				return ec.fieldContext_Dataset_contentType(ctx, field)
			case "field":
				return ec.fieldContext_Dataset_field(ctx, field)
			case "versions":
				return ec.fieldContext_Dataset_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasetMutation_updateDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasetMutation_deleteDatasets(ctx context.Context, field graphql.CollectedField, obj *DatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasetMutation_deleteDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetMutation().DeleteDatasets(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasetMutation_deleteDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasetMutation_deleteDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasetQuery_getDataset(ctx context.Context, field graphql.CollectedField, obj *DatasetQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasetQuery_getDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetQuery().GetDataset(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Dataset)
	fc.Result = res
	return ec.marshalNDataset2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasetQuery_getDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasetQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Dataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Dataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Dataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Dataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Dataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Dataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Dataset_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Dataset_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Dataset_updateTimestamp(ctx, field)
			case "contentType":
				return ec.fieldContext_Dataset_contentType(ctx, field)
			case "field":
				return ec.fieldContext_Dataset_field(ctx, field)
			case "versions":
				return ec.fieldContext_Dataset_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasetQuery_getDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasetQuery_listDatasets(ctx context.Context, field graphql.CollectedField, obj *DatasetQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasetQuery_listDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetQuery().ListDatasets(rctx, obj, fc.Args["input"].(*ListDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasetQuery_listDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasetQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasetQuery_listDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_id(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_name(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_namespace(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_labels(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_annotations(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_creator(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_displayName(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_description(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_endpoint(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_endpoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Endpoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Endpoint)
	fc.Result = res
	return ec.marshalOEndpoint2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_endpoint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_Endpoint_url(ctx, field)
			case "authSecret":
				return ec.fieldContext_Endpoint_authSecret(ctx, field)
			case "insecure":
				return ec.fieldContext_Endpoint_insecure(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Endpoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_oss(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_oss(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Oss, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Oss)
	fc.Result = res
	return ec.marshalOOss2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐOss(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_oss(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bucket":
				return ec.fieldContext_Oss_bucket(ctx, field)
			case "object":
				return ec.fieldContext_Oss_object(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Oss", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_status(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_message(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Datasource_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Datasource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Datasource_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Datasource_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Datasource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceMutation_createDatasource(ctx context.Context, field graphql.CollectedField, obj *DatasourceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceMutation_createDatasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceMutation().CreateDatasource(rctx, obj, fc.Args["input"].(CreateDatasourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Datasource)
	fc.Result = res
	return ec.marshalNDatasource2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceMutation_createDatasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Datasource_id(ctx, field)
			case "name":
				return ec.fieldContext_Datasource_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Datasource_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Datasource_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Datasource_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Datasource_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Datasource_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Datasource_description(ctx, field)
			case "endpoint":
				return ec.fieldContext_Datasource_endpoint(ctx, field)
			case "oss":
				return ec.fieldContext_Datasource_oss(ctx, field)
			case "status":
				return ec.fieldContext_Datasource_status(ctx, field)
			case "message":
				return ec.fieldContext_Datasource_message(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Datasource_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Datasource_updateTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Datasource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceMutation_createDatasource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceMutation_updateDatasource(ctx context.Context, field graphql.CollectedField, obj *DatasourceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceMutation_updateDatasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceMutation().UpdateDatasource(rctx, obj, fc.Args["input"].(*UpdateDatasourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Datasource)
	fc.Result = res
	return ec.marshalNDatasource2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceMutation_updateDatasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Datasource_id(ctx, field)
			case "name":
				return ec.fieldContext_Datasource_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Datasource_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Datasource_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Datasource_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Datasource_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Datasource_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Datasource_description(ctx, field)
			case "endpoint":
				return ec.fieldContext_Datasource_endpoint(ctx, field)
			case "oss":
				return ec.fieldContext_Datasource_oss(ctx, field)
			case "status":
				return ec.fieldContext_Datasource_status(ctx, field)
			case "message":
				return ec.fieldContext_Datasource_message(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Datasource_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Datasource_updateTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Datasource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceMutation_updateDatasource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceMutation_deleteDatasources(ctx context.Context, field graphql.CollectedField, obj *DatasourceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceMutation_deleteDatasources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceMutation().DeleteDatasources(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceMutation_deleteDatasources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceMutation_deleteDatasources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceQuery_getDatasource(ctx context.Context, field graphql.CollectedField, obj *DatasourceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceQuery_getDatasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceQuery().GetDatasource(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Datasource)
	fc.Result = res
	return ec.marshalNDatasource2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceQuery_getDatasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Datasource_id(ctx, field)
			case "name":
				return ec.fieldContext_Datasource_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Datasource_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Datasource_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Datasource_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Datasource_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Datasource_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Datasource_description(ctx, field)
			case "endpoint":
				return ec.fieldContext_Datasource_endpoint(ctx, field)
			case "oss":
				return ec.fieldContext_Datasource_oss(ctx, field)
			case "status":
				return ec.fieldContext_Datasource_status(ctx, field)
			case "message":
				return ec.fieldContext_Datasource_message(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Datasource_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Datasource_updateTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Datasource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceQuery_getDatasource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceQuery_checkDatasource(ctx context.Context, field graphql.CollectedField, obj *DatasourceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceQuery_checkDatasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceQuery().CheckDatasource(rctx, obj, fc.Args["input"].(CreateDatasourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Datasource)
	fc.Result = res
	return ec.marshalNDatasource2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceQuery_checkDatasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Datasource_id(ctx, field)
			case "name":
				return ec.fieldContext_Datasource_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Datasource_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Datasource_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Datasource_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Datasource_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Datasource_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Datasource_description(ctx, field)
			case "endpoint":
				return ec.fieldContext_Datasource_endpoint(ctx, field)
			case "oss":
				return ec.fieldContext_Datasource_oss(ctx, field)
			case "status":
				return ec.fieldContext_Datasource_status(ctx, field)
			case "message":
				return ec.fieldContext_Datasource_message(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Datasource_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Datasource_updateTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Datasource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceQuery_checkDatasource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _DatasourceQuery_listDatasources(ctx context.Context, field graphql.CollectedField, obj *DatasourceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatasourceQuery_listDatasources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasourceQuery().ListDatasources(rctx, obj, fc.Args["input"].(ListCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatasourceQuery_listDatasources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatasourceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_DatasourceQuery_listDatasources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_id(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_name(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_namespace(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_labels(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_annotations(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_creator(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_displayName(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_description(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_baseUrl(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_baseUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_baseUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_models(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_models(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Models, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_models(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_provider(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_type(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_status(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Embedder_message(ctx context.Context, field graphql.CollectedField, obj *Embedder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Embedder_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Embedder_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Embedder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EmbedderMutation_createEmbedder(ctx context.Context, field graphql.CollectedField, obj *EmbedderMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmbedderMutation_createEmbedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EmbedderMutation().CreateEmbedder(rctx, obj, fc.Args["input"].(CreateEmbedderInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Embedder)
	fc.Result = res
	return ec.marshalNEmbedder2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEmbedder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmbedderMutation_createEmbedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbedderMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Embedder_id(ctx, field)
			case "name":
				return ec.fieldContext_Embedder_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Embedder_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Embedder_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Embedder_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Embedder_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Embedder_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Embedder_description(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Embedder_baseUrl(ctx, field)
			case "models":
				return ec.fieldContext_Embedder_models(ctx, field)
			case "provider":
				return ec.fieldContext_Embedder_provider(ctx, field)
			case "type":
				return ec.fieldContext_Embedder_type(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Embedder_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Embedder_updateTimestamp(ctx, field)
			case "status":
				return ec.fieldContext_Embedder_status(ctx, field)
			case "message":
				return ec.fieldContext_Embedder_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Embedder", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_EmbedderMutation_createEmbedder_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EmbedderMutation_updateEmbedder(ctx context.Context, field graphql.CollectedField, obj *EmbedderMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmbedderMutation_updateEmbedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EmbedderMutation().UpdateEmbedder(rctx, obj, fc.Args["input"].(*UpdateEmbedderInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Embedder)
	fc.Result = res
	return ec.marshalNEmbedder2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEmbedder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmbedderMutation_updateEmbedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbedderMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Embedder_id(ctx, field)
			case "name":
				return ec.fieldContext_Embedder_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Embedder_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Embedder_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Embedder_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Embedder_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Embedder_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Embedder_description(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Embedder_baseUrl(ctx, field)
			case "models":
				return ec.fieldContext_Embedder_models(ctx, field)
			case "provider":
				return ec.fieldContext_Embedder_provider(ctx, field)
			case "type":
				return ec.fieldContext_Embedder_type(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Embedder_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Embedder_updateTimestamp(ctx, field)
			case "status":
				return ec.fieldContext_Embedder_status(ctx, field)
			case "message":
				return ec.fieldContext_Embedder_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Embedder", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_EmbedderMutation_updateEmbedder_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EmbedderMutation_deleteEmbedders(ctx context.Context, field graphql.CollectedField, obj *EmbedderMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmbedderMutation_deleteEmbedders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EmbedderMutation().DeleteEmbedders(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmbedderMutation_deleteEmbedders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbedderMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_EmbedderMutation_deleteEmbedders_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EmbedderQuery_getEmbedder(ctx context.Context, field graphql.CollectedField, obj *EmbedderQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmbedderQuery_getEmbedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EmbedderQuery().GetEmbedder(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Embedder)
	fc.Result = res
	return ec.marshalNEmbedder2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEmbedder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmbedderQuery_getEmbedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbedderQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Embedder_id(ctx, field)
			case "name":
				return ec.fieldContext_Embedder_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Embedder_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Embedder_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Embedder_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Embedder_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Embedder_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Embedder_description(ctx, field)
			case "baseUrl":
				return ec.fieldContext_Embedder_baseUrl(ctx, field)
			case "models":
				return ec.fieldContext_Embedder_models(ctx, field)
			case "provider":
				return ec.fieldContext_Embedder_provider(ctx, field)
			case "type":
				return ec.fieldContext_Embedder_type(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Embedder_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Embedder_updateTimestamp(ctx, field)
			case "status":
				return ec.fieldContext_Embedder_status(ctx, field)
			case "message":
				return ec.fieldContext_Embedder_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Embedder", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_EmbedderQuery_getEmbedder_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _EmbedderQuery_listEmbedders(ctx context.Context, field graphql.CollectedField, obj *EmbedderQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmbedderQuery_listEmbedders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EmbedderQuery().ListEmbedders(rctx, obj, fc.Args["input"].(ListCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmbedderQuery_listEmbedders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmbedderQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_EmbedderQuery_listEmbedders_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Endpoint_url(ctx context.Context, field graphql.CollectedField, obj *Endpoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Endpoint_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Endpoint_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Endpoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Endpoint_authSecret(ctx context.Context, field graphql.CollectedField, obj *Endpoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Endpoint_authSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthSecret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Endpoint_authSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Endpoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Endpoint_insecure(ctx context.Context, field graphql.CollectedField, obj *Endpoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Endpoint_insecure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Insecure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Endpoint_insecure(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Endpoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_path(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_fileType(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_fileType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_fileType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_count(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_time(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_size(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _F_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *F) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_F_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_F_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "F",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_id(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_name(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_namespace(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_labels(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_annotations(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_creator(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_displayName(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_description(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_embedder(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_embedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Embedder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_embedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_vectorStore(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_vectorStore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VectorStore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_vectorStore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_fileGroupDetails(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_fileGroupDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileGroupDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Filegroupdetail)
	fc.Result = res
	return ec.marshalOfilegroupdetail2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFilegroupdetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_fileGroupDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "source":
				return ec.fieldContext_filegroupdetail_source(ctx, field)
			case "filedetails":
				return ec.fieldContext_filegroupdetail_filedetails(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type filegroupdetail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_status(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_reason(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBase_message(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBase) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBase_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBase_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBase",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBaseMutation_createKnowledgeBase(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBaseMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBaseMutation_createKnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KnowledgeBaseMutation().CreateKnowledgeBase(rctx, obj, fc.Args["input"].(CreateKnowledgeBaseInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*KnowledgeBase)
	fc.Result = res
	return ec.marshalNKnowledgeBase2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐKnowledgeBase(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBaseMutation_createKnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBaseMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KnowledgeBase_id(ctx, field)
			case "name":
				return ec.fieldContext_KnowledgeBase_name(ctx, field)
			case "namespace":
				return ec.fieldContext_KnowledgeBase_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_KnowledgeBase_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_KnowledgeBase_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_KnowledgeBase_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_KnowledgeBase_displayName(ctx, field)
			case "description":
				return ec.fieldContext_KnowledgeBase_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_KnowledgeBase_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_KnowledgeBase_updateTimestamp(ctx, field)
			case "embedder":
				return ec.fieldContext_KnowledgeBase_embedder(ctx, field)
			case "vectorStore":
				return ec.fieldContext_KnowledgeBase_vectorStore(ctx, field)
			case "fileGroupDetails":
				return ec.fieldContext_KnowledgeBase_fileGroupDetails(ctx, field)
			case "status":
				return ec.fieldContext_KnowledgeBase_status(ctx, field)
			case "reason":
				return ec.fieldContext_KnowledgeBase_reason(ctx, field)
			case "message":
				return ec.fieldContext_KnowledgeBase_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KnowledgeBase", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KnowledgeBaseMutation_createKnowledgeBase_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBaseMutation_updateKnowledgeBase(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBaseMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBaseMutation_updateKnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KnowledgeBaseMutation().UpdateKnowledgeBase(rctx, obj, fc.Args["input"].(*UpdateKnowledgeBaseInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*KnowledgeBase)
	fc.Result = res
	return ec.marshalNKnowledgeBase2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐKnowledgeBase(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBaseMutation_updateKnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBaseMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KnowledgeBase_id(ctx, field)
			case "name":
				return ec.fieldContext_KnowledgeBase_name(ctx, field)
			case "namespace":
				return ec.fieldContext_KnowledgeBase_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_KnowledgeBase_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_KnowledgeBase_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_KnowledgeBase_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_KnowledgeBase_displayName(ctx, field)
			case "description":
				return ec.fieldContext_KnowledgeBase_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_KnowledgeBase_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_KnowledgeBase_updateTimestamp(ctx, field)
			case "embedder":
				return ec.fieldContext_KnowledgeBase_embedder(ctx, field)
			case "vectorStore":
				return ec.fieldContext_KnowledgeBase_vectorStore(ctx, field)
			case "fileGroupDetails":
				return ec.fieldContext_KnowledgeBase_fileGroupDetails(ctx, field)
			case "status":
				return ec.fieldContext_KnowledgeBase_status(ctx, field)
			case "reason":
				return ec.fieldContext_KnowledgeBase_reason(ctx, field)
			case "message":
				return ec.fieldContext_KnowledgeBase_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KnowledgeBase", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KnowledgeBaseMutation_updateKnowledgeBase_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBaseMutation_deleteKnowledgeBase(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBaseMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBaseMutation_deleteKnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KnowledgeBaseMutation().DeleteKnowledgeBase(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBaseMutation_deleteKnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBaseMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KnowledgeBaseMutation_deleteKnowledgeBase_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBaseQuery_getKnowledgeBase(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBaseQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBaseQuery_getKnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KnowledgeBaseQuery().GetKnowledgeBase(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*KnowledgeBase)
	fc.Result = res
	return ec.marshalNKnowledgeBase2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐKnowledgeBase(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBaseQuery_getKnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBaseQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_KnowledgeBase_id(ctx, field)
			case "name":
				return ec.fieldContext_KnowledgeBase_name(ctx, field)
			case "namespace":
				return ec.fieldContext_KnowledgeBase_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_KnowledgeBase_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_KnowledgeBase_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_KnowledgeBase_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_KnowledgeBase_displayName(ctx, field)
			case "description":
				return ec.fieldContext_KnowledgeBase_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_KnowledgeBase_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_KnowledgeBase_updateTimestamp(ctx, field)
			case "embedder":
				return ec.fieldContext_KnowledgeBase_embedder(ctx, field)
			case "vectorStore":
				return ec.fieldContext_KnowledgeBase_vectorStore(ctx, field)
			case "fileGroupDetails":
				return ec.fieldContext_KnowledgeBase_fileGroupDetails(ctx, field)
			case "status":
				return ec.fieldContext_KnowledgeBase_status(ctx, field)
			case "reason":
				return ec.fieldContext_KnowledgeBase_reason(ctx, field)
			case "message":
				return ec.fieldContext_KnowledgeBase_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KnowledgeBase", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KnowledgeBaseQuery_getKnowledgeBase_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _KnowledgeBaseQuery_listKnowledgeBases(ctx context.Context, field graphql.CollectedField, obj *KnowledgeBaseQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KnowledgeBaseQuery_listKnowledgeBases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.KnowledgeBaseQuery().ListKnowledgeBases(rctx, obj, fc.Args["input"].(ListKnowledgeBaseInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KnowledgeBaseQuery_listKnowledgeBases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KnowledgeBaseQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_KnowledgeBaseQuery_listKnowledgeBases_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _LLM_id(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_name(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_namespace(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_labels(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_annotations(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_creator(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_displayName(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_description(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_baseUrl(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_baseUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_baseUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_models(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_models(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Models, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_models(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_provider(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_type(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_status(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLM_message(ctx context.Context, field graphql.CollectedField, obj *Llm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLM_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLM_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLM",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_name(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_namespace(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_model(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_temperature(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_temperature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Temperature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_temperature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_top_p(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_top_p(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TopP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_top_p(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_max_tokens(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_max_tokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxTokens, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_max_tokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_prompt_template(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_prompt_template(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PromptTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_prompt_template(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMConfig_provider(ctx context.Context, field graphql.CollectedField, obj *LLMConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMConfig_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMConfig_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LLMQuery_getLLM(ctx context.Context, field graphql.CollectedField, obj *LLMQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMQuery_getLLM(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LLMQuery().GetLlm(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Llm)
	fc.Result = res
	return ec.marshalNLLM2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐLlm(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMQuery_getLLM(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LLM_id(ctx, field)
			case "name":
				return ec.fieldContext_LLM_name(ctx, field)
			case "namespace":
				return ec.fieldContext_LLM_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_LLM_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_LLM_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_LLM_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_LLM_displayName(ctx, field)
			case "description":
				return ec.fieldContext_LLM_description(ctx, field)
			case "baseUrl":
				return ec.fieldContext_LLM_baseUrl(ctx, field)
			case "models":
				return ec.fieldContext_LLM_models(ctx, field)
			case "provider":
				return ec.fieldContext_LLM_provider(ctx, field)
			case "type":
				return ec.fieldContext_LLM_type(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_LLM_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_LLM_updateTimestamp(ctx, field)
			case "status":
				return ec.fieldContext_LLM_status(ctx, field)
			case "message":
				return ec.fieldContext_LLM_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LLM", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LLMQuery_getLLM_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _LLMQuery_listLLMs(ctx context.Context, field graphql.CollectedField, obj *LLMQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LLMQuery_listLLMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LLMQuery().ListLLMs(rctx, obj, fc.Args["input"].(ListCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LLMQuery_listLLMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LLMQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LLMQuery_listLLMs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Model_id(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_name(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_namespace(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_systemModel(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_systemModel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemModel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_systemModel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_labels(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_annotations(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_creator(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_displayName(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_description(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_types(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_status(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_message(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Model_files(ctx context.Context, field graphql.CollectedField, obj *Model) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Model_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Model().Files(rctx, obj, fc.Args["input"].(*FileFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Model_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Model",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Model_files_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelMutation_createModel(ctx context.Context, field graphql.CollectedField, obj *ModelMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelMutation_createModel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelMutation().CreateModel(rctx, obj, fc.Args["input"].(CreateModelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Model)
	fc.Result = res
	return ec.marshalNModel2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelMutation_createModel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Model_id(ctx, field)
			case "name":
				return ec.fieldContext_Model_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Model_namespace(ctx, field)
			case "systemModel":
				return ec.fieldContext_Model_systemModel(ctx, field)
			case "labels":
				return ec.fieldContext_Model_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Model_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Model_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Model_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Model_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Model_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Model_updateTimestamp(ctx, field)
			case "types":
				return ec.fieldContext_Model_types(ctx, field)
			case "status":
				return ec.fieldContext_Model_status(ctx, field)
			case "message":
				return ec.fieldContext_Model_message(ctx, field)
			case "files":
				return ec.fieldContext_Model_files(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Model", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelMutation_createModel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelMutation_updateModel(ctx context.Context, field graphql.CollectedField, obj *ModelMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelMutation_updateModel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelMutation().UpdateModel(rctx, obj, fc.Args["input"].(*UpdateModelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Model)
	fc.Result = res
	return ec.marshalNModel2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelMutation_updateModel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Model_id(ctx, field)
			case "name":
				return ec.fieldContext_Model_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Model_namespace(ctx, field)
			case "systemModel":
				return ec.fieldContext_Model_systemModel(ctx, field)
			case "labels":
				return ec.fieldContext_Model_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Model_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Model_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Model_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Model_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Model_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Model_updateTimestamp(ctx, field)
			case "types":
				return ec.fieldContext_Model_types(ctx, field)
			case "status":
				return ec.fieldContext_Model_status(ctx, field)
			case "message":
				return ec.fieldContext_Model_message(ctx, field)
			case "files":
				return ec.fieldContext_Model_files(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Model", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelMutation_updateModel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelMutation_deleteModels(ctx context.Context, field graphql.CollectedField, obj *ModelMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelMutation_deleteModels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelMutation().DeleteModels(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelMutation_deleteModels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelMutation_deleteModels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelQuery_getModel(ctx context.Context, field graphql.CollectedField, obj *ModelQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelQuery_getModel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelQuery().GetModel(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Model)
	fc.Result = res
	return ec.marshalNModel2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelQuery_getModel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Model_id(ctx, field)
			case "name":
				return ec.fieldContext_Model_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Model_namespace(ctx, field)
			case "systemModel":
				return ec.fieldContext_Model_systemModel(ctx, field)
			case "labels":
				return ec.fieldContext_Model_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Model_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Model_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Model_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Model_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Model_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Model_updateTimestamp(ctx, field)
			case "types":
				return ec.fieldContext_Model_types(ctx, field)
			case "status":
				return ec.fieldContext_Model_status(ctx, field)
			case "message":
				return ec.fieldContext_Model_message(ctx, field)
			case "files":
				return ec.fieldContext_Model_files(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Model", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelQuery_getModel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelQuery_listModels(ctx context.Context, field graphql.CollectedField, obj *ModelQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelQuery_listModels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelQuery().ListModels(rctx, obj, fc.Args["input"].(ListModelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelQuery_listModels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelQuery_listModels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_id(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_name(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_namespace(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_labels(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_annotations(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_creator(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_displayName(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_description(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_providerType(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_providerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_providerType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_types(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_apiType(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_apiType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_apiType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_llmModels(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_llmModels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LlmModels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_llmModels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_embeddingModels(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_embeddingModels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmbeddingModels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_embeddingModels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_baseUrl(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_baseUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_baseUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_status(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelService_message(ctx context.Context, field graphql.CollectedField, obj *ModelService) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelService_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelService_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelService",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceMutation_createModelService(ctx context.Context, field graphql.CollectedField, obj *ModelServiceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceMutation_createModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceMutation().CreateModelService(rctx, obj, fc.Args["input"].(CreateModelServiceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ModelService)
	fc.Result = res
	return ec.marshalNModelService2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceMutation_createModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModelService_id(ctx, field)
			case "name":
				return ec.fieldContext_ModelService_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ModelService_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_ModelService_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ModelService_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_ModelService_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_ModelService_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ModelService_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ModelService_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ModelService_updateTimestamp(ctx, field)
			case "providerType":
				return ec.fieldContext_ModelService_providerType(ctx, field)
			case "types":
				return ec.fieldContext_ModelService_types(ctx, field)
			case "apiType":
				return ec.fieldContext_ModelService_apiType(ctx, field)
			case "llmModels":
				return ec.fieldContext_ModelService_llmModels(ctx, field)
			case "embeddingModels":
				return ec.fieldContext_ModelService_embeddingModels(ctx, field)
			case "baseUrl":
				return ec.fieldContext_ModelService_baseUrl(ctx, field)
			case "status":
				return ec.fieldContext_ModelService_status(ctx, field)
			case "message":
				return ec.fieldContext_ModelService_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelService", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceMutation_createModelService_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceMutation_updateModelService(ctx context.Context, field graphql.CollectedField, obj *ModelServiceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceMutation_updateModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceMutation().UpdateModelService(rctx, obj, fc.Args["input"].(*UpdateModelServiceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ModelService)
	fc.Result = res
	return ec.marshalNModelService2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceMutation_updateModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModelService_id(ctx, field)
			case "name":
				return ec.fieldContext_ModelService_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ModelService_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_ModelService_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ModelService_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_ModelService_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_ModelService_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ModelService_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ModelService_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ModelService_updateTimestamp(ctx, field)
			case "providerType":
				return ec.fieldContext_ModelService_providerType(ctx, field)
			case "types":
				return ec.fieldContext_ModelService_types(ctx, field)
			case "apiType":
				return ec.fieldContext_ModelService_apiType(ctx, field)
			case "llmModels":
				return ec.fieldContext_ModelService_llmModels(ctx, field)
			case "embeddingModels":
				return ec.fieldContext_ModelService_embeddingModels(ctx, field)
			case "baseUrl":
				return ec.fieldContext_ModelService_baseUrl(ctx, field)
			case "status":
				return ec.fieldContext_ModelService_status(ctx, field)
			case "message":
				return ec.fieldContext_ModelService_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelService", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceMutation_updateModelService_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceMutation_deleteModelService(ctx context.Context, field graphql.CollectedField, obj *ModelServiceMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceMutation_deleteModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceMutation().DeleteModelService(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceMutation_deleteModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceMutation_deleteModelService_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceQuery_getModelService(ctx context.Context, field graphql.CollectedField, obj *ModelServiceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceQuery_getModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceQuery().GetModelService(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ModelService)
	fc.Result = res
	return ec.marshalNModelService2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceQuery_getModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModelService_id(ctx, field)
			case "name":
				return ec.fieldContext_ModelService_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ModelService_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_ModelService_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ModelService_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_ModelService_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_ModelService_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ModelService_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ModelService_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ModelService_updateTimestamp(ctx, field)
			case "providerType":
				return ec.fieldContext_ModelService_providerType(ctx, field)
			case "types":
				return ec.fieldContext_ModelService_types(ctx, field)
			case "apiType":
				return ec.fieldContext_ModelService_apiType(ctx, field)
			case "llmModels":
				return ec.fieldContext_ModelService_llmModels(ctx, field)
			case "embeddingModels":
				return ec.fieldContext_ModelService_embeddingModels(ctx, field)
			case "baseUrl":
				return ec.fieldContext_ModelService_baseUrl(ctx, field)
			case "status":
				return ec.fieldContext_ModelService_status(ctx, field)
			case "message":
				return ec.fieldContext_ModelService_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelService", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceQuery_getModelService_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceQuery_listModelServices(ctx context.Context, field graphql.CollectedField, obj *ModelServiceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceQuery_listModelServices(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceQuery().ListModelServices(rctx, obj, fc.Args["input"].(*ListModelServiceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceQuery_listModelServices(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceQuery_listModelServices_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ModelServiceQuery_checkModelService(ctx context.Context, field graphql.CollectedField, obj *ModelServiceQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModelServiceQuery_checkModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ModelServiceQuery().CheckModelService(rctx, obj, fc.Args["input"].(CreateModelServiceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ModelService)
	fc.Result = res
	return ec.marshalNModelService2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModelServiceQuery_checkModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModelServiceQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModelService_id(ctx, field)
			case "name":
				return ec.fieldContext_ModelService_name(ctx, field)
			case "namespace":
				return ec.fieldContext_ModelService_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_ModelService_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_ModelService_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_ModelService_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_ModelService_displayName(ctx, field)
			case "description":
				return ec.fieldContext_ModelService_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_ModelService_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_ModelService_updateTimestamp(ctx, field)
			case "providerType":
				return ec.fieldContext_ModelService_providerType(ctx, field)
			case "types":
				return ec.fieldContext_ModelService_types(ctx, field)
			case "apiType":
				return ec.fieldContext_ModelService_apiType(ctx, field)
			case "llmModels":
				return ec.fieldContext_ModelService_llmModels(ctx, field)
			case "embeddingModels":
				return ec.fieldContext_ModelService_embeddingModels(ctx, field)
			case "baseUrl":
				return ec.fieldContext_ModelService_baseUrl(ctx, field)
			case "status":
				return ec.fieldContext_ModelService_status(ctx, field)
			case "message":
				return ec.fieldContext_ModelService_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelService", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ModelServiceQuery_checkModelService_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_hello(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_hello(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Hello(rctx, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_hello(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_hello_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Application(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Application(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationMutation)
	fc.Result = res
	return ec.marshalOApplicationMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplicationMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createApplication":
				return ec.fieldContext_ApplicationMutation_createApplication(ctx, field)
			case "updateApplication":
				return ec.fieldContext_ApplicationMutation_updateApplication(ctx, field)
			case "deleteApplication":
				return ec.fieldContext_ApplicationMutation_deleteApplication(ctx, field)
			case "updateApplicationConfig":
				return ec.fieldContext_ApplicationMutation_updateApplicationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_dataProcess(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_dataProcess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DataProcess(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessMutation)
	fc.Result = res
	return ec.marshalODataProcessMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_dataProcess(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createDataProcessTask":
				return ec.fieldContext_DataProcessMutation_createDataProcessTask(ctx, field)
			case "deleteDataProcessTask":
				return ec.fieldContext_DataProcessMutation_deleteDataProcessTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Dataset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Dataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Dataset(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DatasetMutation)
	fc.Result = res
	return ec.marshalODatasetMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasetMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Dataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createDataset":
				return ec.fieldContext_DatasetMutation_createDataset(ctx, field)
			case "updateDataset":
				return ec.fieldContext_DatasetMutation_updateDataset(ctx, field)
			case "deleteDatasets":
				return ec.fieldContext_DatasetMutation_deleteDatasets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DatasetMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Datasource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Datasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Datasource(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DatasourceMutation)
	fc.Result = res
	return ec.marshalODatasourceMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasourceMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Datasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createDatasource":
				return ec.fieldContext_DatasourceMutation_createDatasource(ctx, field)
			case "updateDatasource":
				return ec.fieldContext_DatasourceMutation_updateDatasource(ctx, field)
			case "deleteDatasources":
				return ec.fieldContext_DatasourceMutation_deleteDatasources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DatasourceMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Embedder(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Embedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Embedder(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EmbedderMutation)
	fc.Result = res
	return ec.marshalOEmbedderMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEmbedderMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Embedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createEmbedder":
				return ec.fieldContext_EmbedderMutation_createEmbedder(ctx, field)
			case "updateEmbedder":
				return ec.fieldContext_EmbedderMutation_updateEmbedder(ctx, field)
			case "deleteEmbedders":
				return ec.fieldContext_EmbedderMutation_deleteEmbedders(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EmbedderMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_KnowledgeBase(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_KnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().KnowledgeBase(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*KnowledgeBaseMutation)
	fc.Result = res
	return ec.marshalOKnowledgeBaseMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐKnowledgeBaseMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_KnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createKnowledgeBase":
				return ec.fieldContext_KnowledgeBaseMutation_createKnowledgeBase(ctx, field)
			case "updateKnowledgeBase":
				return ec.fieldContext_KnowledgeBaseMutation_updateKnowledgeBase(ctx, field)
			case "deleteKnowledgeBase":
				return ec.fieldContext_KnowledgeBaseMutation_deleteKnowledgeBase(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KnowledgeBaseMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Model(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Model(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ModelMutation)
	fc.Result = res
	return ec.marshalOModelMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createModel":
				return ec.fieldContext_ModelMutation_createModel(ctx, field)
			case "updateModel":
				return ec.fieldContext_ModelMutation_updateModel(ctx, field)
			case "deleteModels":
				return ec.fieldContext_ModelMutation_deleteModels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ModelService(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ModelService(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ModelServiceMutation)
	fc.Result = res
	return ec.marshalOModelServiceMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelServiceMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createModelService":
				return ec.fieldContext_ModelServiceMutation_createModelService(ctx, field)
			case "updateModelService":
				return ec.fieldContext_ModelServiceMutation_updateModelService(ctx, field)
			case "deleteModelService":
				return ec.fieldContext_ModelServiceMutation_deleteModelService(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelServiceMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_VersionedDataset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_VersionedDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().VersionedDataset(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*VersionedDatasetMutation)
	fc.Result = res
	return ec.marshalOVersionedDatasetMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐVersionedDatasetMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_VersionedDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createVersionedDataset":
				return ec.fieldContext_VersionedDatasetMutation_createVersionedDataset(ctx, field)
			case "updateVersionedDataset":
				return ec.fieldContext_VersionedDatasetMutation_updateVersionedDataset(ctx, field)
			case "deleteVersionedDatasets":
				return ec.fieldContext_VersionedDatasetMutation_deleteVersionedDatasets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionedDatasetMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_Worker(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_Worker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Worker(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*WorkerMutation)
	fc.Result = res
	return ec.marshalOWorkerMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐWorkerMutation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_Worker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "createWorker":
				return ec.fieldContext_WorkerMutation_createWorker(ctx, field)
			case "updateWorker":
				return ec.fieldContext_WorkerMutation_updateWorker(ctx, field)
			case "deleteWorkers":
				return ec.fieldContext_WorkerMutation_deleteWorkers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkerMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Oss_bucket(ctx context.Context, field graphql.CollectedField, obj *Oss) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Oss_bucket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bucket, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Oss_bucket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Oss",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Oss_object(ctx context.Context, field graphql.CollectedField, obj *Oss) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Oss_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Oss_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Oss",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedDataProcessItem_status(ctx context.Context, field graphql.CollectedField, obj *PaginatedDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedDataProcessItem_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedDataProcessItem_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedDataProcessItem_data(ctx context.Context, field graphql.CollectedField, obj *PaginatedDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedDataProcessItem_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*DataProcessItem)
	fc.Result = res
	return ec.marshalODataProcessItem2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedDataProcessItem_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DataProcessItem_id(ctx, field)
			case "name":
				return ec.fieldContext_DataProcessItem_name(ctx, field)
			case "status":
				return ec.fieldContext_DataProcessItem_status(ctx, field)
			case "pre_data_set_name":
				return ec.fieldContext_DataProcessItem_pre_data_set_name(ctx, field)
			case "pre_data_set_version":
				return ec.fieldContext_DataProcessItem_pre_data_set_version(ctx, field)
			case "post_data_set_name":
				return ec.fieldContext_DataProcessItem_post_data_set_name(ctx, field)
			case "post_data_set_version":
				return ec.fieldContext_DataProcessItem_post_data_set_version(ctx, field)
			case "start_datetime":
				return ec.fieldContext_DataProcessItem_start_datetime(ctx, field)
			case "error_msg":
				return ec.fieldContext_DataProcessItem_error_msg(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedDataProcessItem_message(ctx context.Context, field graphql.CollectedField, obj *PaginatedDataProcessItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedDataProcessItem_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedDataProcessItem_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedDataProcessItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedResult_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *PaginatedResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedResult_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedResult_nodes(ctx context.Context, field graphql.CollectedField, obj *PaginatedResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedResult_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]PageNode)
	fc.Result = res
	return ec.marshalOPageNode2ᚕgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPageNodeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedResult_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PageNode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedResult_page(ctx context.Context, field graphql.CollectedField, obj *PaginatedResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedResult_page(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Page, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedResult_page(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedResult_pageSize(ctx context.Context, field graphql.CollectedField, obj *PaginatedResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedResult_pageSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedResult_pageSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PaginatedResult_totalCount(ctx context.Context, field graphql.CollectedField, obj *PaginatedResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PaginatedResult_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PaginatedResult_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PaginatedResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_hello(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hello(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Hello(rctx, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hello(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hello_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_Application(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Application(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Application(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ApplicationQuery)
	fc.Result = res
	return ec.marshalOApplicationQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplicationQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Application(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getApplication":
				return ec.fieldContext_ApplicationQuery_getApplication(ctx, field)
			case "listApplicationMetadata":
				return ec.fieldContext_ApplicationQuery_listApplicationMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ApplicationQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_dataProcess(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_dataProcess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DataProcess(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DataProcessQuery)
	fc.Result = res
	return ec.marshalODataProcessQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_dataProcess(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allDataProcessListByPage":
				return ec.fieldContext_DataProcessQuery_allDataProcessListByPage(ctx, field)
			case "allDataProcessListByCount":
				return ec.fieldContext_DataProcessQuery_allDataProcessListByCount(ctx, field)
			case "dataProcessSupportType":
				return ec.fieldContext_DataProcessQuery_dataProcessSupportType(ctx, field)
			case "dataProcessDetails":
				return ec.fieldContext_DataProcessQuery_dataProcessDetails(ctx, field)
			case "checkDataProcessTaskName":
				return ec.fieldContext_DataProcessQuery_checkDataProcessTaskName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DataProcessQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_Dataset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Dataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Dataset(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DatasetQuery)
	fc.Result = res
	return ec.marshalODatasetQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasetQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Dataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getDataset":
				return ec.fieldContext_DatasetQuery_getDataset(ctx, field)
			case "listDatasets":
				return ec.fieldContext_DatasetQuery_listDatasets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DatasetQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_Datasource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Datasource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Datasource(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DatasourceQuery)
	fc.Result = res
	return ec.marshalODatasourceQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasourceQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Datasource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getDatasource":
				return ec.fieldContext_DatasourceQuery_getDatasource(ctx, field)
			case "checkDatasource":
				return ec.fieldContext_DatasourceQuery_checkDatasource(ctx, field)
			case "listDatasources":
				return ec.fieldContext_DatasourceQuery_listDatasources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DatasourceQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_Embedder(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Embedder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Embedder(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EmbedderQuery)
	fc.Result = res
	return ec.marshalOEmbedderQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEmbedderQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Embedder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getEmbedder":
				return ec.fieldContext_EmbedderQuery_getEmbedder(ctx, field)
			case "listEmbedders":
				return ec.fieldContext_EmbedderQuery_listEmbedders(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EmbedderQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_KnowledgeBase(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_KnowledgeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().KnowledgeBase(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*KnowledgeBaseQuery)
	fc.Result = res
	return ec.marshalOKnowledgeBaseQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐKnowledgeBaseQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_KnowledgeBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getKnowledgeBase":
				return ec.fieldContext_KnowledgeBaseQuery_getKnowledgeBase(ctx, field)
			case "listKnowledgeBases":
				return ec.fieldContext_KnowledgeBaseQuery_listKnowledgeBases(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KnowledgeBaseQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_LLM(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_LLM(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Llm(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*LLMQuery)
	fc.Result = res
	return ec.marshalOLLMQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐLLMQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_LLM(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getLLM":
				return ec.fieldContext_LLMQuery_getLLM(ctx, field)
			case "listLLMs":
				return ec.fieldContext_LLMQuery_listLLMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LLMQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_Model(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Model(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ModelQuery)
	fc.Result = res
	return ec.marshalOModelQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getModel":
				return ec.fieldContext_ModelQuery_getModel(ctx, field)
			case "listModels":
				return ec.fieldContext_ModelQuery_listModels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ModelService(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ModelService(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ModelService(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ModelServiceQuery)
	fc.Result = res
	return ec.marshalOModelServiceQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelServiceQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ModelService(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getModelService":
				return ec.fieldContext_ModelServiceQuery_getModelService(ctx, field)
			case "listModelServices":
				return ec.fieldContext_ModelServiceQuery_listModelServices(ctx, field)
			case "checkModelService":
				return ec.fieldContext_ModelServiceQuery_checkModelService(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModelServiceQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_VersionedDataset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_VersionedDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().VersionedDataset(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*VersionedDatasetQuery)
	fc.Result = res
	return ec.marshalOVersionedDatasetQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐVersionedDatasetQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_VersionedDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getVersionedDataset":
				return ec.fieldContext_VersionedDatasetQuery_getVersionedDataset(ctx, field)
			case "listVersionedDatasets":
				return ec.fieldContext_VersionedDatasetQuery_listVersionedDatasets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionedDatasetQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_Worker(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_Worker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Worker(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*WorkerQuery)
	fc.Result = res
	return ec.marshalOWorkerQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐWorkerQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_Worker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "getWorker":
				return ec.fieldContext_WorkerQuery_getWorker(ctx, field)
			case "listWorkers":
				return ec.fieldContext_WorkerQuery_listWorkers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkerQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resources_cpu(ctx context.Context, field graphql.CollectedField, obj *Resources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resources_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resources_cpu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resources_memory(ctx context.Context, field graphql.CollectedField, obj *Resources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resources_memory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Memory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resources_memory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resources_nvidiaGPU(ctx context.Context, field graphql.CollectedField, obj *Resources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resources_nvidiaGPU(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NvidiaGpu, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resources_nvidiaGPU(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypedObjectReference_apiGroup(ctx context.Context, field graphql.CollectedField, obj *TypedObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypedObjectReference_apiGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypedObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypedObjectReference_kind(ctx context.Context, field graphql.CollectedField, obj *TypedObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypedObjectReference_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypedObjectReference_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypedObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypedObjectReference_name(ctx context.Context, field graphql.CollectedField, obj *TypedObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypedObjectReference_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypedObjectReference_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypedObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypedObjectReference_namespace(ctx context.Context, field graphql.CollectedField, obj *TypedObjectReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypedObjectReference_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypedObjectReference_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypedObjectReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_id(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_name(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_namespace(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_labels(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_annotations(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_creator(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_displayName(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_description(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_dataset(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_dataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dataset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TypedObjectReference)
	fc.Result = res
	return ec.marshalNTypedObjectReference2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_dataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_files(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDataset().Files(rctx, obj, fc.Args["input"].(*FileFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDataset_files_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_version(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_released(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_released(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Released, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_released(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_syncStatus(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_syncStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SyncStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_syncStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDataset_dataProcessStatus(ctx context.Context, field graphql.CollectedField, obj *VersionedDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDataset_dataProcessStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataProcessStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDataset_dataProcessStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDatasetMutation_createVersionedDataset(ctx context.Context, field graphql.CollectedField, obj *VersionedDatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDatasetMutation_createVersionedDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDatasetMutation().CreateVersionedDataset(rctx, obj, fc.Args["input"].(CreateVersionedDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*VersionedDataset)
	fc.Result = res
	return ec.marshalNVersionedDataset2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐVersionedDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDatasetMutation_createVersionedDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_VersionedDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_VersionedDataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_VersionedDataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_VersionedDataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_VersionedDataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_VersionedDataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_VersionedDataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_VersionedDataset_description(ctx, field)
			case "dataset":
				return ec.fieldContext_VersionedDataset_dataset(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_VersionedDataset_updateTimestamp(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_VersionedDataset_creationTimestamp(ctx, field)
			case "files":
				return ec.fieldContext_VersionedDataset_files(ctx, field)
			case "version":
				return ec.fieldContext_VersionedDataset_version(ctx, field)
			case "released":
				return ec.fieldContext_VersionedDataset_released(ctx, field)
			case "syncStatus":
				return ec.fieldContext_VersionedDataset_syncStatus(ctx, field)
			case "dataProcessStatus":
				return ec.fieldContext_VersionedDataset_dataProcessStatus(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionedDataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDatasetMutation_createVersionedDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDatasetMutation_updateVersionedDataset(ctx context.Context, field graphql.CollectedField, obj *VersionedDatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDatasetMutation_updateVersionedDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDatasetMutation().UpdateVersionedDataset(rctx, obj, fc.Args["input"].(UpdateVersionedDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*VersionedDataset)
	fc.Result = res
	return ec.marshalNVersionedDataset2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐVersionedDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDatasetMutation_updateVersionedDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_VersionedDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_VersionedDataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_VersionedDataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_VersionedDataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_VersionedDataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_VersionedDataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_VersionedDataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_VersionedDataset_description(ctx, field)
			case "dataset":
				return ec.fieldContext_VersionedDataset_dataset(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_VersionedDataset_updateTimestamp(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_VersionedDataset_creationTimestamp(ctx, field)
			case "files":
				return ec.fieldContext_VersionedDataset_files(ctx, field)
			case "version":
				return ec.fieldContext_VersionedDataset_version(ctx, field)
			case "released":
				return ec.fieldContext_VersionedDataset_released(ctx, field)
			case "syncStatus":
				return ec.fieldContext_VersionedDataset_syncStatus(ctx, field)
			case "dataProcessStatus":
				return ec.fieldContext_VersionedDataset_dataProcessStatus(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionedDataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDatasetMutation_updateVersionedDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDatasetMutation_deleteVersionedDatasets(ctx context.Context, field graphql.CollectedField, obj *VersionedDatasetMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDatasetMutation_deleteVersionedDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDatasetMutation().DeleteVersionedDatasets(rctx, obj, fc.Args["input"].(DeleteVersionedDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDatasetMutation_deleteVersionedDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDatasetMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDatasetMutation_deleteVersionedDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDatasetQuery_getVersionedDataset(ctx context.Context, field graphql.CollectedField, obj *VersionedDatasetQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDatasetQuery_getVersionedDataset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDatasetQuery().GetVersionedDataset(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*VersionedDataset)
	fc.Result = res
	return ec.marshalNVersionedDataset2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐVersionedDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDatasetQuery_getVersionedDataset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDatasetQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_VersionedDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_VersionedDataset_name(ctx, field)
			case "namespace":
				return ec.fieldContext_VersionedDataset_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_VersionedDataset_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_VersionedDataset_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_VersionedDataset_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_VersionedDataset_displayName(ctx, field)
			case "description":
				return ec.fieldContext_VersionedDataset_description(ctx, field)
			case "dataset":
				return ec.fieldContext_VersionedDataset_dataset(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_VersionedDataset_updateTimestamp(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_VersionedDataset_creationTimestamp(ctx, field)
			case "files":
				return ec.fieldContext_VersionedDataset_files(ctx, field)
			case "version":
				return ec.fieldContext_VersionedDataset_version(ctx, field)
			case "released":
				return ec.fieldContext_VersionedDataset_released(ctx, field)
			case "syncStatus":
				return ec.fieldContext_VersionedDataset_syncStatus(ctx, field)
			case "dataProcessStatus":
				return ec.fieldContext_VersionedDataset_dataProcessStatus(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionedDataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDatasetQuery_getVersionedDataset_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VersionedDatasetQuery_listVersionedDatasets(ctx context.Context, field graphql.CollectedField, obj *VersionedDatasetQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionedDatasetQuery_listVersionedDatasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionedDatasetQuery().ListVersionedDatasets(rctx, obj, fc.Args["input"].(ListVersionedDatasetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionedDatasetQuery_listVersionedDatasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionedDatasetQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_VersionedDatasetQuery_listVersionedDatasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Worker_id(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_name(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_namespace(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_namespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_namespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_labels(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_annotations(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_annotations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_annotations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_creator(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_displayName(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_description(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_creationTimestamp(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_creationTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_creationTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_type(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_model(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TypedObjectReference)
	fc.Result = res
	return ec.marshalNTypedObjectReference2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_modelTypes(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_modelTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModelTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_modelTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_replicas(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_replicas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Replicas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_replicas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_resources(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Resources)
	fc.Result = res
	return ec.marshalNResources2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐResources(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_resources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpu":
				return ec.fieldContext_Resources_cpu(ctx, field)
			case "memory":
				return ec.fieldContext_Resources_memory(ctx, field)
			case "nvidiaGPU":
				return ec.fieldContext_Resources_nvidiaGPU(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_status(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_message(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Worker_api(ctx context.Context, field graphql.CollectedField, obj *Worker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Worker_api(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.API, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Worker_api(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Worker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkerMutation_createWorker(ctx context.Context, field graphql.CollectedField, obj *WorkerMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkerMutation_createWorker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkerMutation().CreateWorker(rctx, obj, fc.Args["input"].(CreateWorkerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Worker)
	fc.Result = res
	return ec.marshalNWorker2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐWorker(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkerMutation_createWorker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkerMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Worker_id(ctx, field)
			case "name":
				return ec.fieldContext_Worker_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Worker_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Worker_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Worker_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Worker_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Worker_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Worker_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Worker_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Worker_updateTimestamp(ctx, field)
			case "type":
				return ec.fieldContext_Worker_type(ctx, field)
			case "model":
				return ec.fieldContext_Worker_model(ctx, field)
			case "modelTypes":
				return ec.fieldContext_Worker_modelTypes(ctx, field)
			case "replicas":
				return ec.fieldContext_Worker_replicas(ctx, field)
			case "resources":
				return ec.fieldContext_Worker_resources(ctx, field)
			case "status":
				return ec.fieldContext_Worker_status(ctx, field)
			case "message":
				return ec.fieldContext_Worker_message(ctx, field)
			case "api":
				return ec.fieldContext_Worker_api(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Worker", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkerMutation_createWorker_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkerMutation_updateWorker(ctx context.Context, field graphql.CollectedField, obj *WorkerMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkerMutation_updateWorker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkerMutation().UpdateWorker(rctx, obj, fc.Args["input"].(*UpdateWorkerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Worker)
	fc.Result = res
	return ec.marshalNWorker2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐWorker(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkerMutation_updateWorker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkerMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Worker_id(ctx, field)
			case "name":
				return ec.fieldContext_Worker_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Worker_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Worker_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Worker_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Worker_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Worker_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Worker_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Worker_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Worker_updateTimestamp(ctx, field)
			case "type":
				return ec.fieldContext_Worker_type(ctx, field)
			case "model":
				return ec.fieldContext_Worker_model(ctx, field)
			case "modelTypes":
				return ec.fieldContext_Worker_modelTypes(ctx, field)
			case "replicas":
				return ec.fieldContext_Worker_replicas(ctx, field)
			case "resources":
				return ec.fieldContext_Worker_resources(ctx, field)
			case "status":
				return ec.fieldContext_Worker_status(ctx, field)
			case "message":
				return ec.fieldContext_Worker_message(ctx, field)
			case "api":
				return ec.fieldContext_Worker_api(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Worker", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkerMutation_updateWorker_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkerMutation_deleteWorkers(ctx context.Context, field graphql.CollectedField, obj *WorkerMutation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkerMutation_deleteWorkers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkerMutation().DeleteWorkers(rctx, obj, fc.Args["input"].(*DeleteCommonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVoid2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkerMutation_deleteWorkers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkerMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Void does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkerMutation_deleteWorkers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkerQuery_getWorker(ctx context.Context, field graphql.CollectedField, obj *WorkerQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkerQuery_getWorker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkerQuery().GetWorker(rctx, obj, fc.Args["name"].(string), fc.Args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Worker)
	fc.Result = res
	return ec.marshalNWorker2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐWorker(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkerQuery_getWorker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkerQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Worker_id(ctx, field)
			case "name":
				return ec.fieldContext_Worker_name(ctx, field)
			case "namespace":
				return ec.fieldContext_Worker_namespace(ctx, field)
			case "labels":
				return ec.fieldContext_Worker_labels(ctx, field)
			case "annotations":
				return ec.fieldContext_Worker_annotations(ctx, field)
			case "creator":
				return ec.fieldContext_Worker_creator(ctx, field)
			case "displayName":
				return ec.fieldContext_Worker_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Worker_description(ctx, field)
			case "creationTimestamp":
				return ec.fieldContext_Worker_creationTimestamp(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_Worker_updateTimestamp(ctx, field)
			case "type":
				return ec.fieldContext_Worker_type(ctx, field)
			case "model":
				return ec.fieldContext_Worker_model(ctx, field)
			case "modelTypes":
				return ec.fieldContext_Worker_modelTypes(ctx, field)
			case "replicas":
				return ec.fieldContext_Worker_replicas(ctx, field)
			case "resources":
				return ec.fieldContext_Worker_resources(ctx, field)
			case "status":
				return ec.fieldContext_Worker_status(ctx, field)
			case "message":
				return ec.fieldContext_Worker_message(ctx, field)
			case "api":
				return ec.fieldContext_Worker_api(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Worker", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkerQuery_getWorker_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WorkerQuery_listWorkers(ctx context.Context, field graphql.CollectedField, obj *WorkerQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkerQuery_listWorkers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WorkerQuery().ListWorkers(rctx, obj, fc.Args["input"].(ListWorkerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginatedResult)
	fc.Result = res
	return ec.marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkerQuery_listWorkers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkerQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PaginatedResult_hasNextPage(ctx, field)
			case "nodes":
				return ec.fieldContext_PaginatedResult_nodes(ctx, field)
			case "page":
				return ec.fieldContext_PaginatedResult_page(ctx, field)
			case "pageSize":
				return ec.fieldContext_PaginatedResult_pageSize(ctx, field)
			case "totalCount":
				return ec.fieldContext_PaginatedResult_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PaginatedResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_WorkerQuery_listWorkers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_path(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_fileType(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_fileType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_fileType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_count(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_size(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_updateTimestamp(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_updateTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_updateTimestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filedetail_phase(ctx context.Context, field graphql.CollectedField, obj *Filedetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filedetail_phase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filedetail_phase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filedetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filegroup_source(ctx context.Context, field graphql.CollectedField, obj *Filegroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filegroup_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filegroup_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filegroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _filegroup_path(ctx context.Context, field graphql.CollectedField, obj *Filegroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filegroup_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filegroup_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filegroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _filegroupdetail_source(ctx context.Context, field graphql.CollectedField, obj *Filegroupdetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filegroupdetail_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypedObjectReference)
	fc.Result = res
	return ec.marshalOTypedObjectReference2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filegroupdetail_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filegroupdetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiGroup":
				return ec.fieldContext_TypedObjectReference_apiGroup(ctx, field)
			case "kind":
				return ec.fieldContext_TypedObjectReference_kind(ctx, field)
			case "name":
				return ec.fieldContext_TypedObjectReference_name(ctx, field)
			case "namespace":
				return ec.fieldContext_TypedObjectReference_namespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypedObjectReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _filegroupdetail_filedetails(ctx context.Context, field graphql.CollectedField, obj *Filegroupdetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_filegroupdetail_filedetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Filedetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Filedetail)
	fc.Result = res
	return ec.marshalOfiledetail2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFiledetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_filegroupdetail_filedetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "filegroupdetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "path":
				return ec.fieldContext_filedetail_path(ctx, field)
			case "fileType":
				return ec.fieldContext_filedetail_fileType(ctx, field)
			case "count":
				return ec.fieldContext_filedetail_count(ctx, field)
			case "size":
				return ec.fieldContext_filedetail_size(ctx, field)
			case "updateTimestamp":
				return ec.fieldContext_filedetail_updateTimestamp(ctx, field)
			case "phase":
				return ec.fieldContext_filedetail_phase(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type filedetail", field.Name)
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddDataProcessInput(ctx context.Context, obj interface{}) (AddDataProcessInput, error) {
	var it AddDataProcessInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "file_type", "pre_data_set_name", "pre_data_set_version", "file_names", "post_data_set_name", "post_data_set_version", "data_process_config_info", "bucket_name", "version_data_set_name", "namespace", "creator"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "file_type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file_type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileType = data
		case "pre_data_set_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pre_data_set_name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreDataSetName = data
		case "pre_data_set_version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pre_data_set_version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreDataSetVersion = data
		case "file_names":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file_names"))
			data, err := ec.unmarshalOFileItem2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileItemᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileNames = data
		case "post_data_set_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("post_data_set_name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PostDataSetName = data
		case "post_data_set_version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("post_data_set_version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PostDataSetVersion = data
		case "data_process_config_info":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data_process_config_info"))
			data, err := ec.unmarshalODataProcessConfigItem2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigItemᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DataProcessConfigInfo = data
		case "bucket_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bucket_name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BucketName = data
		case "version_data_set_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version_data_set_name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionDataSetName = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "creator":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creator"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Creator = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAllDataProcessListByCountInput(ctx context.Context, obj interface{}) (AllDataProcessListByCountInput, error) {
	var it AllDataProcessListByCountInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"keyword", "namespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAllDataProcessListByPageInput(ctx context.Context, obj interface{}) (AllDataProcessListByPageInput, error) {
	var it AllDataProcessListByPageInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pageIndex", "pageSize", "keyword", "namespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pageIndex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageIndex"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageIndex = data
		case "pageSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCheckDataProcessTaskNameInput(ctx context.Context, obj interface{}) (CheckDataProcessTaskNameInput, error) {
	var it CheckDataProcessTaskNameInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateApplicationMetadataInput(ctx context.Context, obj interface{}) (CreateApplicationMetadataInput, error) {
	var it CreateApplicationMetadataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "icon", "isPublic"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "icon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "isPublic":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPublic"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPublic = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDatasetInput(ctx context.Context, obj interface{}) (CreateDatasetInput, error) {
	var it CreateDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "contentType", "filed"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "contentType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContentType = data
		case "filed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filed"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filed = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDatasourceInput(ctx context.Context, obj interface{}) (CreateDatasourceInput, error) {
	var it CreateDatasourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "ossinput"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalNEndpointInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "ossinput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ossinput"))
			data, err := ec.unmarshalOOssInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐOssInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ossinput = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEmbedderInput(ctx context.Context, obj interface{}) (CreateEmbedderInput, error) {
	var it CreateEmbedderInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalNEndpointInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateKnowledgeBaseInput(ctx context.Context, obj interface{}) (CreateKnowledgeBaseInput, error) {
	var it CreateKnowledgeBaseInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "embedder", "vectorStore", "fileGroups"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "embedder":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embedder"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Embedder = data
		case "vectorStore":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vectorStore"))
			data, err := ec.unmarshalOTypedObjectReferenceInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.VectorStore = data
		case "fileGroups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileGroups"))
			data, err := ec.unmarshalOfilegroupinput2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFilegroupinputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileGroups = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLLMInput(ctx context.Context, obj interface{}) (CreateLLMInput, error) {
	var it CreateLLMInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalNEndpointInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateModelInput(ctx context.Context, obj interface{}) (CreateModelInput, error) {
	var it CreateModelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "displayName", "description", "types"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "types":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateModelServiceInput(ctx context.Context, obj interface{}) (CreateModelServiceInput, error) {
	var it CreateModelServiceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "types", "apiType", "endpoint", "llmModels", "embeddingModels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "types":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		case "apiType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIType = data
		case "endpoint":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpoint"))
			data, err := ec.unmarshalNEndpointInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpoint = data
		case "llmModels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("llmModels"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LlmModels = data
		case "embeddingModels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embeddingModels"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmbeddingModels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateVersionedDatasetInput(ctx context.Context, obj interface{}) (CreateVersionedDatasetInput, error) {
	var it CreateVersionedDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "datasetName", "labels", "annotations", "displayName", "description", "version", "released", "fileGrups", "inheritedFrom"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "datasetName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datasetName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DatasetName = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "released":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("released"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Released = data
		case "fileGrups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileGrups"))
			data, err := ec.unmarshalOFileGroup2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileGroup(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileGrups = data
		case "inheritedFrom":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inheritedFrom"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.InheritedFrom = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateWorkerInput(ctx context.Context, obj interface{}) (CreateWorkerInput, error) {
	var it CreateWorkerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "displayName", "description", "type", "model", "resources"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "model":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalNTypedObjectReferenceInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = data
		case "resources":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resources"))
			data, err := ec.unmarshalNResourcesInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐResourcesInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Resources = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDataProcessConfigItem(ctx context.Context, obj interface{}) (DataProcessConfigItem, error) {
	var it DataProcessConfigItem
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "llm_config"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "llm_config":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("llm_config"))
			data, err := ec.unmarshalOLLMConfigItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐLLMConfigItem(ctx, v)
			if err != nil {
				return it, err
			}
			it.LlmConfig = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDataProcessDetailsInput(ctx context.Context, obj interface{}) (DataProcessDetailsInput, error) {
	var it DataProcessDetailsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteCommonInput(ctx context.Context, obj interface{}) (DeleteCommonInput, error) {
	var it DeleteCommonInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labelSelector", "fieldSelector"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labelSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteDataProcessInput(ctx context.Context, obj interface{}) (DeleteDataProcessInput, error) {
	var it DeleteDataProcessInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteVersionedDatasetInput(ctx context.Context, obj interface{}) (DeleteVersionedDatasetInput, error) {
	var it DeleteVersionedDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labelSelector", "fieldSelector"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labelSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEndpointInput(ctx context.Context, obj interface{}) (EndpointInput, error) {
	var it EndpointInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "auth", "insecure"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "auth":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("auth"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Auth = data
		case "insecure":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("insecure"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Insecure = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFileFilter(ctx context.Context, obj interface{}) (FileFilter, error) {
	var it FileFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"keyword", "page", "pageSize", "sortBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "sortBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFileGroup(ctx context.Context, obj interface{}) (FileGroup, error) {
	var it FileGroup
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"source", "paths"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "source":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalNTypedObjectReferenceInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Source = data
		case "paths":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paths"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Paths = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFileItem(ctx context.Context, obj interface{}) (FileItem, error) {
	var it FileItem
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLLMConfigItem(ctx context.Context, obj interface{}) (LLMConfigItem, error) {
	var it LLMConfigItem
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "model", "temperature", "top_p", "max_tokens", "prompt_template"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "model":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = data
		case "temperature":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("temperature"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Temperature = data
		case "top_p":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("top_p"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TopP = data
		case "max_tokens":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_tokens"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTokens = data
		case "prompt_template":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prompt_template"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PromptTemplate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListCommonInput(ctx context.Context, obj interface{}) (ListCommonInput, error) {
	var it ListCommonInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "keyword", "labelSelector", "fieldSelector", "page", "pageSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "labelSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListDatasetInput(ctx context.Context, obj interface{}) (ListDatasetInput, error) {
	var it ListDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "name", "displayName", "labelSelector", "fieldSelector", "page", "pageSize", "keyword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "labelSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListKnowledgeBaseInput(ctx context.Context, obj interface{}) (ListKnowledgeBaseInput, error) {
	var it ListKnowledgeBaseInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "displayName", "labelSelector", "fieldSelector", "page", "pageSize", "keyword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "labelSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListModelInput(ctx context.Context, obj interface{}) (ListModelInput, error) {
	var it ListModelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "systemModel", "keyword", "labelSelector", "fieldSelector", "page", "pageSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "systemModel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("systemModel"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SystemModel = data
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "labelSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListModelServiceInput(ctx context.Context, obj interface{}) (ListModelServiceInput, error) {
	var it ListModelServiceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"keyword", "namespace", "page", "pageSize", "types", "providerType", "apiType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "types":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		case "providerType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderType = data
		case "apiType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListVersionedDatasetInput(ctx context.Context, obj interface{}) (ListVersionedDatasetInput, error) {
	var it ListVersionedDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "displayName", "labelSelector", "fieldSelector", "page", "pageSize", "keyword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "labelSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListWorkerInput(ctx context.Context, obj interface{}) (ListWorkerInput, error) {
	var it ListWorkerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"namespace", "keyword", "labelSelector", "fieldSelector", "page", "pageSize", "modelTypes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "keyword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keyword = data
		case "labelSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labelSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LabelSelector = data
		case "fieldSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldSelector = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		case "modelTypes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modelTypes"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModelTypes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOssInput(ctx context.Context, obj interface{}) (OssInput, error) {
	var it OssInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"bucket", "object"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "bucket":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bucket"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bucket = data
		case "object":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("object"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Object = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourcesInput(ctx context.Context, obj interface{}) (ResourcesInput, error) {
	var it ResourcesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cpu", "memory", "nvidiaGPU"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cpu":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cpu"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CPU = data
		case "memory":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memory"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Memory = data
		case "nvidiaGPU":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nvidiaGPU"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NvidiaGpu = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypedObjectReferenceInput(ctx context.Context, obj interface{}) (TypedObjectReferenceInput, error) {
	var it TypedObjectReferenceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"apiGroup", "kind", "name", "namespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "apiGroup":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiGroup"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIGroup = data
		case "kind":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kind"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Kind = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateApplicationConfigInput(ctx context.Context, obj interface{}) (UpdateApplicationConfigInput, error) {
	var it UpdateApplicationConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "prologue", "model", "llm", "temperature", "maxLength", "conversionWindowSize", "knowledgebase", "scoreThreshold", "numDocuments", "docNullReturn", "userPrompt", "showNextGuid"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "prologue":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prologue"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Prologue = data
		case "model":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = data
		case "llm":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("llm"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Llm = data
		case "temperature":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("temperature"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Temperature = data
		case "maxLength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLength"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLength = data
		case "conversionWindowSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversionWindowSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversionWindowSize = data
		case "knowledgebase":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("knowledgebase"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Knowledgebase = data
		case "scoreThreshold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreThreshold"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreThreshold = data
		case "numDocuments":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numDocuments"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumDocuments = data
		case "docNullReturn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("docNullReturn"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DocNullReturn = data
		case "userPrompt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPrompt"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserPrompt = data
		case "showNextGuid":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showNextGuid"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowNextGUID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateApplicationMetadataInput(ctx context.Context, obj interface{}) (UpdateApplicationMetadataInput, error) {
	var it UpdateApplicationMetadataInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "icon", "isPublic"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "icon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "isPublic":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPublic"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPublic = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDatasetInput(ctx context.Context, obj interface{}) (UpdateDatasetInput, error) {
	var it UpdateDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDatasourceInput(ctx context.Context, obj interface{}) (UpdateDatasourceInput, error) {
	var it UpdateDatasourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "ossinput"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalOEndpointInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "ossinput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ossinput"))
			data, err := ec.unmarshalOOssInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐOssInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ossinput = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEmbedderInput(ctx context.Context, obj interface{}) (UpdateEmbedderInput, error) {
	var it UpdateEmbedderInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalOEndpointInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateKnowledgeBaseInput(ctx context.Context, obj interface{}) (UpdateKnowledgeBaseInput, error) {
	var it UpdateKnowledgeBaseInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "fileGroups"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "fileGroups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileGroups"))
			data, err := ec.unmarshalOfilegroupinput2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFilegroupinputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileGroups = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLLMInput(ctx context.Context, obj interface{}) (UpdateLLMInput, error) {
	var it UpdateLLMInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "endpointinput", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "endpointinput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpointinput"))
			data, err := ec.unmarshalOEndpointInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpointinput = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateModelInput(ctx context.Context, obj interface{}) (UpdateModelInput, error) {
	var it UpdateModelInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "types"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "types":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateModelServiceInput(ctx context.Context, obj interface{}) (UpdateModelServiceInput, error) {
	var it UpdateModelServiceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "types", "apiType", "endpoint", "llmModels", "embeddingModels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "types":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Types = data
		case "apiType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIType = data
		case "endpoint":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpoint"))
			data, err := ec.unmarshalNEndpointInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpoint = data
		case "llmModels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("llmModels"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LlmModels = data
		case "embeddingModels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("embeddingModels"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmbeddingModels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateVersionedDatasetInput(ctx context.Context, obj interface{}) (UpdateVersionedDatasetInput, error) {
	var it UpdateVersionedDatasetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "fileGroups", "released"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "fileGroups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileGroups"))
			data, err := ec.unmarshalOFileGroup2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileGroupᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileGroups = data
		case "released":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("released"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Released = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateWorkerInput(ctx context.Context, obj interface{}) (UpdateWorkerInput, error) {
	var it UpdateWorkerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "namespace", "labels", "annotations", "displayName", "description", "type", "replicas", "resources"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "namespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namespace"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Namespace = data
		case "labels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		case "annotations":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("annotations"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotations = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "replicas":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("replicas"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Replicas = data
		case "resources":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resources"))
			data, err := ec.unmarshalOResourcesInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐResourcesInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Resources = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputfilegroupinput(ctx context.Context, obj interface{}) (Filegroupinput, error) {
	var it Filegroupinput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"source", "path"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "source":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalNTypedObjectReferenceInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Source = data
		case "path":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _PageNode(ctx context.Context, sel ast.SelectionSet, obj PageNode) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case Datasource:
		return ec._Datasource(ctx, sel, &obj)
	case *Datasource:
		if obj == nil {
			return graphql.Null
		}
		return ec._Datasource(ctx, sel, obj)
	case Model:
		return ec._Model(ctx, sel, &obj)
	case *Model:
		if obj == nil {
			return graphql.Null
		}
		return ec._Model(ctx, sel, obj)
	case Embedder:
		return ec._Embedder(ctx, sel, &obj)
	case *Embedder:
		if obj == nil {
			return graphql.Null
		}
		return ec._Embedder(ctx, sel, obj)
	case KnowledgeBase:
		return ec._KnowledgeBase(ctx, sel, &obj)
	case *KnowledgeBase:
		if obj == nil {
			return graphql.Null
		}
		return ec._KnowledgeBase(ctx, sel, obj)
	case Dataset:
		return ec._Dataset(ctx, sel, &obj)
	case *Dataset:
		if obj == nil {
			return graphql.Null
		}
		return ec._Dataset(ctx, sel, obj)
	case VersionedDataset:
		return ec._VersionedDataset(ctx, sel, &obj)
	case *VersionedDataset:
		if obj == nil {
			return graphql.Null
		}
		return ec._VersionedDataset(ctx, sel, obj)
	case F:
		return ec._F(ctx, sel, &obj)
	case *F:
		if obj == nil {
			return graphql.Null
		}
		return ec._F(ctx, sel, obj)
	case Worker:
		return ec._Worker(ctx, sel, &obj)
	case *Worker:
		if obj == nil {
			return graphql.Null
		}
		return ec._Worker(ctx, sel, obj)
	case ApplicationMetadata:
		return ec._ApplicationMetadata(ctx, sel, &obj)
	case *ApplicationMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._ApplicationMetadata(ctx, sel, obj)
	case Llm:
		return ec._LLM(ctx, sel, &obj)
	case *Llm:
		if obj == nil {
			return graphql.Null
		}
		return ec._LLM(ctx, sel, obj)
	case ModelService:
		return ec._ModelService(ctx, sel, &obj)
	case *ModelService:
		if obj == nil {
			return graphql.Null
		}
		return ec._ModelService(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var applicationImplementors = []string{"Application"}

func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *Application) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "metadata":
			out.Values[i] = ec._Application_metadata(ctx, field, obj)
		case "prologue":
			out.Values[i] = ec._Application_prologue(ctx, field, obj)
		case "model":
			out.Values[i] = ec._Application_model(ctx, field, obj)
		case "llm":
			out.Values[i] = ec._Application_llm(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "temperature":
			out.Values[i] = ec._Application_temperature(ctx, field, obj)
		case "maxLength":
			out.Values[i] = ec._Application_maxLength(ctx, field, obj)
		case "conversionWindowSize":
			out.Values[i] = ec._Application_conversionWindowSize(ctx, field, obj)
		case "knowledgebase":
			out.Values[i] = ec._Application_knowledgebase(ctx, field, obj)
		case "scoreThreshold":
			out.Values[i] = ec._Application_scoreThreshold(ctx, field, obj)
		case "numDocuments":
			out.Values[i] = ec._Application_numDocuments(ctx, field, obj)
		case "docNullReturn":
			out.Values[i] = ec._Application_docNullReturn(ctx, field, obj)
		case "userPrompt":
			out.Values[i] = ec._Application_userPrompt(ctx, field, obj)
		case "showNextGuid":
			out.Values[i] = ec._Application_showNextGuid(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationMetadataImplementors = []string{"ApplicationMetadata", "PageNode"}

func (ec *executionContext) _ApplicationMetadata(ctx context.Context, sel ast.SelectionSet, obj *ApplicationMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationMetadata")
		case "name":
			out.Values[i] = ec._ApplicationMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._ApplicationMetadata_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "id":
			out.Values[i] = ec._ApplicationMetadata_id(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._ApplicationMetadata_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._ApplicationMetadata_annotations(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._ApplicationMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ApplicationMetadata_description(ctx, field, obj)
		case "icon":
			out.Values[i] = ec._ApplicationMetadata_icon(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._ApplicationMetadata_creator(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._ApplicationMetadata_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._ApplicationMetadata_updateTimestamp(ctx, field, obj)
		case "isPublic":
			out.Values[i] = ec._ApplicationMetadata_isPublic(ctx, field, obj)
		case "status":
			out.Values[i] = ec._ApplicationMetadata_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationMutationImplementors = []string{"ApplicationMutation"}

func (ec *executionContext) _ApplicationMutation(ctx context.Context, sel ast.SelectionSet, obj *ApplicationMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationMutation")
		case "createApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationMutation_createApplication(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationMutation_updateApplication(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationMutation_deleteApplication(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateApplicationConfig":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationMutation_updateApplicationConfig(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var applicationQueryImplementors = []string{"ApplicationQuery"}

func (ec *executionContext) _ApplicationQuery(ctx context.Context, sel ast.SelectionSet, obj *ApplicationQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationQuery")
		case "getApplication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationQuery_getApplication(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listApplicationMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationQuery_listApplicationMetadata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var countDataProcessItemImplementors = []string{"CountDataProcessItem"}

func (ec *executionContext) _CountDataProcessItem(ctx context.Context, sel ast.SelectionSet, obj *CountDataProcessItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, countDataProcessItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CountDataProcessItem")
		case "status":
			out.Values[i] = ec._CountDataProcessItem_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._CountDataProcessItem_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._CountDataProcessItem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigImplementors = []string{"DataProcessConfig"}

func (ec *executionContext) _DataProcessConfig(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfig")
		case "name":
			out.Values[i] = ec._DataProcessConfig_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DataProcessConfig_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "file_num":
			out.Values[i] = ec._DataProcessConfig_file_num(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._DataProcessConfig_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "children":
			out.Values[i] = ec._DataProcessConfig_children(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigChildrenImplementors = []string{"DataProcessConfigChildren"}

func (ec *executionContext) _DataProcessConfigChildren(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfigChildren) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigChildrenImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfigChildren")
		case "name":
			out.Values[i] = ec._DataProcessConfigChildren_name(ctx, field, obj)
		case "enable":
			out.Values[i] = ec._DataProcessConfigChildren_enable(ctx, field, obj)
		case "zh_name":
			out.Values[i] = ec._DataProcessConfigChildren_zh_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._DataProcessConfigChildren_description(ctx, field, obj)
		case "llm_config":
			out.Values[i] = ec._DataProcessConfigChildren_llm_config(ctx, field, obj)
		case "preview":
			out.Values[i] = ec._DataProcessConfigChildren_preview(ctx, field, obj)
		case "file_progress":
			out.Values[i] = ec._DataProcessConfigChildren_file_progress(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigpreFileProgressImplementors = []string{"DataProcessConfigpreFileProgress"}

func (ec *executionContext) _DataProcessConfigpreFileProgress(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfigpreFileProgress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigpreFileProgressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfigpreFileProgress")
		case "id":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_id(ctx, field, obj)
		case "file_name":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_file_name(ctx, field, obj)
		case "status":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_status(ctx, field, obj)
		case "start_time":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_start_time(ctx, field, obj)
		case "end_time":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_end_time(ctx, field, obj)
		case "progress":
			out.Values[i] = ec._DataProcessConfigpreFileProgress_progress(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigpreViewImplementors = []string{"DataProcessConfigpreView"}

func (ec *executionContext) _DataProcessConfigpreView(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfigpreView) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigpreViewImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfigpreView")
		case "file_name":
			out.Values[i] = ec._DataProcessConfigpreView_file_name(ctx, field, obj)
		case "content":
			out.Values[i] = ec._DataProcessConfigpreView_content(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessConfigpreViewContentImplementors = []string{"DataProcessConfigpreViewContent"}

func (ec *executionContext) _DataProcessConfigpreViewContent(ctx context.Context, sel ast.SelectionSet, obj *DataProcessConfigpreViewContent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessConfigpreViewContentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessConfigpreViewContent")
		case "pre":
			out.Values[i] = ec._DataProcessConfigpreViewContent_pre(ctx, field, obj)
		case "post":
			out.Values[i] = ec._DataProcessConfigpreViewContent_post(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessDetailsImplementors = []string{"DataProcessDetails"}

func (ec *executionContext) _DataProcessDetails(ctx context.Context, sel ast.SelectionSet, obj *DataProcessDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessDetails")
		case "status":
			out.Values[i] = ec._DataProcessDetails_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._DataProcessDetails_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._DataProcessDetails_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessDetailsItemImplementors = []string{"DataProcessDetailsItem"}

func (ec *executionContext) _DataProcessDetailsItem(ctx context.Context, sel ast.SelectionSet, obj *DataProcessDetailsItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessDetailsItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessDetailsItem")
		case "id":
			out.Values[i] = ec._DataProcessDetailsItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._DataProcessDetailsItem_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._DataProcessDetailsItem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "file_type":
			out.Values[i] = ec._DataProcessDetailsItem_file_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pre_dataset_name":
			out.Values[i] = ec._DataProcessDetailsItem_pre_dataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pre_dataset_version":
			out.Values[i] = ec._DataProcessDetailsItem_pre_dataset_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "post_dataset_name":
			out.Values[i] = ec._DataProcessDetailsItem_post_dataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "post_dataset_version":
			out.Values[i] = ec._DataProcessDetailsItem_post_dataset_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "file_num":
			out.Values[i] = ec._DataProcessDetailsItem_file_num(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "start_time":
			out.Values[i] = ec._DataProcessDetailsItem_start_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "end_time":
			out.Values[i] = ec._DataProcessDetailsItem_end_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creator":
			out.Values[i] = ec._DataProcessDetailsItem_creator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error_msg":
			out.Values[i] = ec._DataProcessDetailsItem_error_msg(ctx, field, obj)
		case "config":
			out.Values[i] = ec._DataProcessDetailsItem_config(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessItemImplementors = []string{"DataProcessItem"}

func (ec *executionContext) _DataProcessItem(ctx context.Context, sel ast.SelectionSet, obj *DataProcessItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessItem")
		case "id":
			out.Values[i] = ec._DataProcessItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._DataProcessItem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._DataProcessItem_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pre_data_set_name":
			out.Values[i] = ec._DataProcessItem_pre_data_set_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pre_data_set_version":
			out.Values[i] = ec._DataProcessItem_pre_data_set_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "post_data_set_name":
			out.Values[i] = ec._DataProcessItem_post_data_set_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "post_data_set_version":
			out.Values[i] = ec._DataProcessItem_post_data_set_version(ctx, field, obj)
		case "start_datetime":
			out.Values[i] = ec._DataProcessItem_start_datetime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error_msg":
			out.Values[i] = ec._DataProcessItem_error_msg(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessMutationImplementors = []string{"DataProcessMutation"}

func (ec *executionContext) _DataProcessMutation(ctx context.Context, sel ast.SelectionSet, obj *DataProcessMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessMutation")
		case "createDataProcessTask":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessMutation_createDataProcessTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteDataProcessTask":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessMutation_deleteDataProcessTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessQueryImplementors = []string{"DataProcessQuery"}

func (ec *executionContext) _DataProcessQuery(ctx context.Context, sel ast.SelectionSet, obj *DataProcessQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessQuery")
		case "allDataProcessListByPage":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_allDataProcessListByPage(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "allDataProcessListByCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_allDataProcessListByCount(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dataProcessSupportType":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_dataProcessSupportType(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dataProcessDetails":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_dataProcessDetails(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "checkDataProcessTaskName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DataProcessQuery_checkDataProcessTaskName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessResponseImplementors = []string{"DataProcessResponse"}

func (ec *executionContext) _DataProcessResponse(ctx context.Context, sel ast.SelectionSet, obj *DataProcessResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessResponse")
		case "status":
			out.Values[i] = ec._DataProcessResponse_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._DataProcessResponse_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._DataProcessResponse_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessSupportTypeImplementors = []string{"DataProcessSupportType"}

func (ec *executionContext) _DataProcessSupportType(ctx context.Context, sel ast.SelectionSet, obj *DataProcessSupportType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessSupportTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessSupportType")
		case "status":
			out.Values[i] = ec._DataProcessSupportType_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._DataProcessSupportType_data(ctx, field, obj)
		case "message":
			out.Values[i] = ec._DataProcessSupportType_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessSupportTypeChildrenImplementors = []string{"DataProcessSupportTypeChildren"}

func (ec *executionContext) _DataProcessSupportTypeChildren(ctx context.Context, sel ast.SelectionSet, obj *DataProcessSupportTypeChildren) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessSupportTypeChildrenImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessSupportTypeChildren")
		case "name":
			out.Values[i] = ec._DataProcessSupportTypeChildren_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zh_name":
			out.Values[i] = ec._DataProcessSupportTypeChildren_zh_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enable":
			out.Values[i] = ec._DataProcessSupportTypeChildren_enable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DataProcessSupportTypeChildren_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dataProcessSupportTypeItemImplementors = []string{"DataProcessSupportTypeItem"}

func (ec *executionContext) _DataProcessSupportTypeItem(ctx context.Context, sel ast.SelectionSet, obj *DataProcessSupportTypeItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dataProcessSupportTypeItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DataProcessSupportTypeItem")
		case "name":
			out.Values[i] = ec._DataProcessSupportTypeItem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DataProcessSupportTypeItem_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "children":
			out.Values[i] = ec._DataProcessSupportTypeItem_children(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasetImplementors = []string{"Dataset", "PageNode"}

func (ec *executionContext) _Dataset(ctx context.Context, sel ast.SelectionSet, obj *Dataset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dataset")
		case "name":
			out.Values[i] = ec._Dataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "namespace":
			out.Values[i] = ec._Dataset_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "labels":
			out.Values[i] = ec._Dataset_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Dataset_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Dataset_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Dataset_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Dataset_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._Dataset_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._Dataset_updateTimestamp(ctx, field, obj)
		case "contentType":
			out.Values[i] = ec._Dataset_contentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "field":
			out.Values[i] = ec._Dataset_field(ctx, field, obj)
		case "versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasetMutationImplementors = []string{"DatasetMutation"}

func (ec *executionContext) _DatasetMutation(ctx context.Context, sel ast.SelectionSet, obj *DatasetMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasetMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatasetMutation")
		case "createDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetMutation_createDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetMutation_updateDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetMutation_deleteDatasets(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasetQueryImplementors = []string{"DatasetQuery"}

func (ec *executionContext) _DatasetQuery(ctx context.Context, sel ast.SelectionSet, obj *DatasetQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasetQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatasetQuery")
		case "getDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetQuery_getDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetQuery_listDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasourceImplementors = []string{"Datasource", "PageNode"}

func (ec *executionContext) _Datasource(ctx context.Context, sel ast.SelectionSet, obj *Datasource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Datasource")
		case "id":
			out.Values[i] = ec._Datasource_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Datasource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._Datasource_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._Datasource_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Datasource_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Datasource_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Datasource_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Datasource_description(ctx, field, obj)
		case "endpoint":
			out.Values[i] = ec._Datasource_endpoint(ctx, field, obj)
		case "oss":
			out.Values[i] = ec._Datasource_oss(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Datasource_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Datasource_message(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._Datasource_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._Datasource_updateTimestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasourceMutationImplementors = []string{"DatasourceMutation"}

func (ec *executionContext) _DatasourceMutation(ctx context.Context, sel ast.SelectionSet, obj *DatasourceMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasourceMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatasourceMutation")
		case "createDatasource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceMutation_createDatasource(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateDatasource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceMutation_updateDatasource(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteDatasources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceMutation_deleteDatasources(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var datasourceQueryImplementors = []string{"DatasourceQuery"}

func (ec *executionContext) _DatasourceQuery(ctx context.Context, sel ast.SelectionSet, obj *DatasourceQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, datasourceQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatasourceQuery")
		case "getDatasource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceQuery_getDatasource(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "checkDatasource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceQuery_checkDatasource(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listDatasources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasourceQuery_listDatasources(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var embedderImplementors = []string{"Embedder", "PageNode"}

func (ec *executionContext) _Embedder(ctx context.Context, sel ast.SelectionSet, obj *Embedder) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, embedderImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Embedder")
		case "id":
			out.Values[i] = ec._Embedder_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Embedder_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._Embedder_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._Embedder_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Embedder_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Embedder_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Embedder_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Embedder_description(ctx, field, obj)
		case "baseUrl":
			out.Values[i] = ec._Embedder_baseUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "models":
			out.Values[i] = ec._Embedder_models(ctx, field, obj)
		case "provider":
			out.Values[i] = ec._Embedder_provider(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Embedder_type(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._Embedder_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._Embedder_updateTimestamp(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Embedder_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Embedder_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var embedderMutationImplementors = []string{"EmbedderMutation"}

func (ec *executionContext) _EmbedderMutation(ctx context.Context, sel ast.SelectionSet, obj *EmbedderMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, embedderMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EmbedderMutation")
		case "createEmbedder":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EmbedderMutation_createEmbedder(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateEmbedder":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EmbedderMutation_updateEmbedder(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteEmbedders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EmbedderMutation_deleteEmbedders(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var embedderQueryImplementors = []string{"EmbedderQuery"}

func (ec *executionContext) _EmbedderQuery(ctx context.Context, sel ast.SelectionSet, obj *EmbedderQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, embedderQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EmbedderQuery")
		case "getEmbedder":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EmbedderQuery_getEmbedder(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listEmbedders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EmbedderQuery_listEmbedders(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var endpointImplementors = []string{"Endpoint"}

func (ec *executionContext) _Endpoint(ctx context.Context, sel ast.SelectionSet, obj *Endpoint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, endpointImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Endpoint")
		case "url":
			out.Values[i] = ec._Endpoint_url(ctx, field, obj)
		case "authSecret":
			out.Values[i] = ec._Endpoint_authSecret(ctx, field, obj)
		case "insecure":
			out.Values[i] = ec._Endpoint_insecure(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fImplementors = []string{"F", "PageNode"}

func (ec *executionContext) _F(ctx context.Context, sel ast.SelectionSet, obj *F) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("F")
		case "path":
			out.Values[i] = ec._F_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileType":
			out.Values[i] = ec._F_fileType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._F_count(ctx, field, obj)
		case "time":
			out.Values[i] = ec._F_time(ctx, field, obj)
		case "size":
			out.Values[i] = ec._F_size(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._F_creationTimestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var knowledgeBaseImplementors = []string{"KnowledgeBase", "PageNode"}

func (ec *executionContext) _KnowledgeBase(ctx context.Context, sel ast.SelectionSet, obj *KnowledgeBase) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, knowledgeBaseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KnowledgeBase")
		case "id":
			out.Values[i] = ec._KnowledgeBase_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._KnowledgeBase_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._KnowledgeBase_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._KnowledgeBase_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._KnowledgeBase_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._KnowledgeBase_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._KnowledgeBase_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._KnowledgeBase_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._KnowledgeBase_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._KnowledgeBase_updateTimestamp(ctx, field, obj)
		case "embedder":
			out.Values[i] = ec._KnowledgeBase_embedder(ctx, field, obj)
		case "vectorStore":
			out.Values[i] = ec._KnowledgeBase_vectorStore(ctx, field, obj)
		case "fileGroupDetails":
			out.Values[i] = ec._KnowledgeBase_fileGroupDetails(ctx, field, obj)
		case "status":
			out.Values[i] = ec._KnowledgeBase_status(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._KnowledgeBase_reason(ctx, field, obj)
		case "message":
			out.Values[i] = ec._KnowledgeBase_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var knowledgeBaseMutationImplementors = []string{"KnowledgeBaseMutation"}

func (ec *executionContext) _KnowledgeBaseMutation(ctx context.Context, sel ast.SelectionSet, obj *KnowledgeBaseMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, knowledgeBaseMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KnowledgeBaseMutation")
		case "createKnowledgeBase":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KnowledgeBaseMutation_createKnowledgeBase(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateKnowledgeBase":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KnowledgeBaseMutation_updateKnowledgeBase(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteKnowledgeBase":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KnowledgeBaseMutation_deleteKnowledgeBase(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var knowledgeBaseQueryImplementors = []string{"KnowledgeBaseQuery"}

func (ec *executionContext) _KnowledgeBaseQuery(ctx context.Context, sel ast.SelectionSet, obj *KnowledgeBaseQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, knowledgeBaseQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KnowledgeBaseQuery")
		case "getKnowledgeBase":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KnowledgeBaseQuery_getKnowledgeBase(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listKnowledgeBases":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._KnowledgeBaseQuery_listKnowledgeBases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lLMImplementors = []string{"LLM", "PageNode"}

func (ec *executionContext) _LLM(ctx context.Context, sel ast.SelectionSet, obj *Llm) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lLMImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LLM")
		case "id":
			out.Values[i] = ec._LLM_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._LLM_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._LLM_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._LLM_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._LLM_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._LLM_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._LLM_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._LLM_description(ctx, field, obj)
		case "baseUrl":
			out.Values[i] = ec._LLM_baseUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "models":
			out.Values[i] = ec._LLM_models(ctx, field, obj)
		case "provider":
			out.Values[i] = ec._LLM_provider(ctx, field, obj)
		case "type":
			out.Values[i] = ec._LLM_type(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._LLM_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._LLM_updateTimestamp(ctx, field, obj)
		case "status":
			out.Values[i] = ec._LLM_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._LLM_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lLMConfigImplementors = []string{"LLMConfig"}

func (ec *executionContext) _LLMConfig(ctx context.Context, sel ast.SelectionSet, obj *LLMConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lLMConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LLMConfig")
		case "name":
			out.Values[i] = ec._LLMConfig_name(ctx, field, obj)
		case "namespace":
			out.Values[i] = ec._LLMConfig_namespace(ctx, field, obj)
		case "model":
			out.Values[i] = ec._LLMConfig_model(ctx, field, obj)
		case "temperature":
			out.Values[i] = ec._LLMConfig_temperature(ctx, field, obj)
		case "top_p":
			out.Values[i] = ec._LLMConfig_top_p(ctx, field, obj)
		case "max_tokens":
			out.Values[i] = ec._LLMConfig_max_tokens(ctx, field, obj)
		case "prompt_template":
			out.Values[i] = ec._LLMConfig_prompt_template(ctx, field, obj)
		case "provider":
			out.Values[i] = ec._LLMConfig_provider(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lLMQueryImplementors = []string{"LLMQuery"}

func (ec *executionContext) _LLMQuery(ctx context.Context, sel ast.SelectionSet, obj *LLMQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lLMQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LLMQuery")
		case "getLLM":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LLMQuery_getLLM(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listLLMs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LLMQuery_listLLMs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelImplementors = []string{"Model", "PageNode"}

func (ec *executionContext) _Model(ctx context.Context, sel ast.SelectionSet, obj *Model) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Model")
		case "id":
			out.Values[i] = ec._Model_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Model_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "namespace":
			out.Values[i] = ec._Model_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "systemModel":
			out.Values[i] = ec._Model_systemModel(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._Model_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Model_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Model_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Model_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Model_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._Model_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._Model_updateTimestamp(ctx, field, obj)
		case "types":
			out.Values[i] = ec._Model_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Model_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Model_message(ctx, field, obj)
		case "files":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Model_files(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelMutationImplementors = []string{"ModelMutation"}

func (ec *executionContext) _ModelMutation(ctx context.Context, sel ast.SelectionSet, obj *ModelMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelMutation")
		case "createModel":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelMutation_createModel(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateModel":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelMutation_updateModel(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteModels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelMutation_deleteModels(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelQueryImplementors = []string{"ModelQuery"}

func (ec *executionContext) _ModelQuery(ctx context.Context, sel ast.SelectionSet, obj *ModelQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelQuery")
		case "getModel":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelQuery_getModel(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listModels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelQuery_listModels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelServiceImplementors = []string{"ModelService", "PageNode"}

func (ec *executionContext) _ModelService(ctx context.Context, sel ast.SelectionSet, obj *ModelService) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelServiceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelService")
		case "id":
			out.Values[i] = ec._ModelService_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._ModelService_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._ModelService_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._ModelService_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._ModelService_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._ModelService_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._ModelService_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ModelService_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._ModelService_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._ModelService_updateTimestamp(ctx, field, obj)
		case "providerType":
			out.Values[i] = ec._ModelService_providerType(ctx, field, obj)
		case "types":
			out.Values[i] = ec._ModelService_types(ctx, field, obj)
		case "apiType":
			out.Values[i] = ec._ModelService_apiType(ctx, field, obj)
		case "llmModels":
			out.Values[i] = ec._ModelService_llmModels(ctx, field, obj)
		case "embeddingModels":
			out.Values[i] = ec._ModelService_embeddingModels(ctx, field, obj)
		case "baseUrl":
			out.Values[i] = ec._ModelService_baseUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._ModelService_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._ModelService_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelServiceMutationImplementors = []string{"ModelServiceMutation"}

func (ec *executionContext) _ModelServiceMutation(ctx context.Context, sel ast.SelectionSet, obj *ModelServiceMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelServiceMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelServiceMutation")
		case "createModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceMutation_createModelService(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceMutation_updateModelService(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceMutation_deleteModelService(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modelServiceQueryImplementors = []string{"ModelServiceQuery"}

func (ec *executionContext) _ModelServiceQuery(ctx context.Context, sel ast.SelectionSet, obj *ModelServiceQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modelServiceQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModelServiceQuery")
		case "getModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceQuery_getModelService(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listModelServices":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceQuery_listModelServices(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "checkModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ModelServiceQuery_checkModelService(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "hello":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_hello(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Application":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Application(ctx, field)
			})
		case "dataProcess":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_dataProcess(ctx, field)
			})
		case "Dataset":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Dataset(ctx, field)
			})
		case "Datasource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Datasource(ctx, field)
			})
		case "Embedder":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Embedder(ctx, field)
			})
		case "KnowledgeBase":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_KnowledgeBase(ctx, field)
			})
		case "Model":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Model(ctx, field)
			})
		case "ModelService":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ModelService(ctx, field)
			})
		case "VersionedDataset":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_VersionedDataset(ctx, field)
			})
		case "Worker":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_Worker(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ossImplementors = []string{"Oss"}

func (ec *executionContext) _Oss(ctx context.Context, sel ast.SelectionSet, obj *Oss) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ossImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Oss")
		case "bucket":
			out.Values[i] = ec._Oss_bucket(ctx, field, obj)
		case "object":
			out.Values[i] = ec._Oss_object(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var paginatedDataProcessItemImplementors = []string{"PaginatedDataProcessItem"}

func (ec *executionContext) _PaginatedDataProcessItem(ctx context.Context, sel ast.SelectionSet, obj *PaginatedDataProcessItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, paginatedDataProcessItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PaginatedDataProcessItem")
		case "status":
			out.Values[i] = ec._PaginatedDataProcessItem_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._PaginatedDataProcessItem_data(ctx, field, obj)
		case "message":
			out.Values[i] = ec._PaginatedDataProcessItem_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var paginatedResultImplementors = []string{"PaginatedResult"}

func (ec *executionContext) _PaginatedResult(ctx context.Context, sel ast.SelectionSet, obj *PaginatedResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, paginatedResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PaginatedResult")
		case "hasNextPage":
			out.Values[i] = ec._PaginatedResult_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodes":
			out.Values[i] = ec._PaginatedResult_nodes(ctx, field, obj)
		case "page":
			out.Values[i] = ec._PaginatedResult_page(ctx, field, obj)
		case "pageSize":
			out.Values[i] = ec._PaginatedResult_pageSize(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._PaginatedResult_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "hello":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hello(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Application":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Application(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "dataProcess":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dataProcess(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Dataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Dataset(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Datasource":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Datasource(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Embedder":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Embedder(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "KnowledgeBase":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_KnowledgeBase(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "LLM":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_LLM(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Model":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Model(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ModelService":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ModelService(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "VersionedDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_VersionedDataset(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "Worker":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Worker(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourcesImplementors = []string{"Resources"}

func (ec *executionContext) _Resources(ctx context.Context, sel ast.SelectionSet, obj *Resources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Resources")
		case "cpu":
			out.Values[i] = ec._Resources_cpu(ctx, field, obj)
		case "memory":
			out.Values[i] = ec._Resources_memory(ctx, field, obj)
		case "nvidiaGPU":
			out.Values[i] = ec._Resources_nvidiaGPU(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var typedObjectReferenceImplementors = []string{"TypedObjectReference"}

func (ec *executionContext) _TypedObjectReference(ctx context.Context, sel ast.SelectionSet, obj *TypedObjectReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typedObjectReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypedObjectReference")
		case "apiGroup":
			out.Values[i] = ec._TypedObjectReference_apiGroup(ctx, field, obj)
		case "kind":
			out.Values[i] = ec._TypedObjectReference_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._TypedObjectReference_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._TypedObjectReference_namespace(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionedDatasetImplementors = []string{"VersionedDataset", "PageNode"}

func (ec *executionContext) _VersionedDataset(ctx context.Context, sel ast.SelectionSet, obj *VersionedDataset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionedDatasetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionedDataset")
		case "id":
			out.Values[i] = ec._VersionedDataset_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._VersionedDataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "namespace":
			out.Values[i] = ec._VersionedDataset_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "labels":
			out.Values[i] = ec._VersionedDataset_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._VersionedDataset_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._VersionedDataset_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._VersionedDataset_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._VersionedDataset_description(ctx, field, obj)
		case "dataset":
			out.Values[i] = ec._VersionedDataset_dataset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTimestamp":
			out.Values[i] = ec._VersionedDataset_updateTimestamp(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._VersionedDataset_creationTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "files":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDataset_files(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "version":
			out.Values[i] = ec._VersionedDataset_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "released":
			out.Values[i] = ec._VersionedDataset_released(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "syncStatus":
			out.Values[i] = ec._VersionedDataset_syncStatus(ctx, field, obj)
		case "dataProcessStatus":
			out.Values[i] = ec._VersionedDataset_dataProcessStatus(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionedDatasetMutationImplementors = []string{"VersionedDatasetMutation"}

func (ec *executionContext) _VersionedDatasetMutation(ctx context.Context, sel ast.SelectionSet, obj *VersionedDatasetMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionedDatasetMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionedDatasetMutation")
		case "createVersionedDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDatasetMutation_createVersionedDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateVersionedDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDatasetMutation_updateVersionedDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteVersionedDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDatasetMutation_deleteVersionedDatasets(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionedDatasetQueryImplementors = []string{"VersionedDatasetQuery"}

func (ec *executionContext) _VersionedDatasetQuery(ctx context.Context, sel ast.SelectionSet, obj *VersionedDatasetQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionedDatasetQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionedDatasetQuery")
		case "getVersionedDataset":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDatasetQuery_getVersionedDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listVersionedDatasets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionedDatasetQuery_listVersionedDatasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workerImplementors = []string{"Worker", "PageNode"}

func (ec *executionContext) _Worker(ctx context.Context, sel ast.SelectionSet, obj *Worker) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Worker")
		case "id":
			out.Values[i] = ec._Worker_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Worker_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "namespace":
			out.Values[i] = ec._Worker_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._Worker_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Worker_annotations(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Worker_creator(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Worker_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Worker_description(ctx, field, obj)
		case "creationTimestamp":
			out.Values[i] = ec._Worker_creationTimestamp(ctx, field, obj)
		case "updateTimestamp":
			out.Values[i] = ec._Worker_updateTimestamp(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Worker_type(ctx, field, obj)
		case "model":
			out.Values[i] = ec._Worker_model(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "modelTypes":
			out.Values[i] = ec._Worker_modelTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "replicas":
			out.Values[i] = ec._Worker_replicas(ctx, field, obj)
		case "resources":
			out.Values[i] = ec._Worker_resources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Worker_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Worker_message(ctx, field, obj)
		case "api":
			out.Values[i] = ec._Worker_api(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workerMutationImplementors = []string{"WorkerMutation"}

func (ec *executionContext) _WorkerMutation(ctx context.Context, sel ast.SelectionSet, obj *WorkerMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workerMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkerMutation")
		case "createWorker":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkerMutation_createWorker(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateWorker":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkerMutation_updateWorker(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleteWorkers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkerMutation_deleteWorkers(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workerQueryImplementors = []string{"WorkerQuery"}

func (ec *executionContext) _WorkerQuery(ctx context.Context, sel ast.SelectionSet, obj *WorkerQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workerQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkerQuery")
		case "getWorker":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkerQuery_getWorker(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "listWorkers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WorkerQuery_listWorkers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filedetailImplementors = []string{"filedetail"}

func (ec *executionContext) _filedetail(ctx context.Context, sel ast.SelectionSet, obj *Filedetail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filedetailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("filedetail")
		case "path":
			out.Values[i] = ec._filedetail_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileType":
			out.Values[i] = ec._filedetail_fileType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "count":
			out.Values[i] = ec._filedetail_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "size":
			out.Values[i] = ec._filedetail_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTimestamp":
			out.Values[i] = ec._filedetail_updateTimestamp(ctx, field, obj)
		case "phase":
			out.Values[i] = ec._filedetail_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filegroupImplementors = []string{"filegroup"}

func (ec *executionContext) _filegroup(ctx context.Context, sel ast.SelectionSet, obj *Filegroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filegroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("filegroup")
		case "source":
			out.Values[i] = ec._filegroup_source(ctx, field, obj)
		case "path":
			out.Values[i] = ec._filegroup_path(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filegroupdetailImplementors = []string{"filegroupdetail"}

func (ec *executionContext) _filegroupdetail(ctx context.Context, sel ast.SelectionSet, obj *Filegroupdetail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filegroupdetailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("filegroupdetail")
		case "source":
			out.Values[i] = ec._filegroupdetail_source(ctx, field, obj)
		case "filedetails":
			out.Values[i] = ec._filegroupdetail_filedetails(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNApplication2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplication(ctx context.Context, sel ast.SelectionSet, v Application) graphql.Marshaler {
	return ec._Application(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplication2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplication(ctx context.Context, sel ast.SelectionSet, v *Application) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationMetadata2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplicationMetadata(ctx context.Context, sel ast.SelectionSet, v ApplicationMetadata) graphql.Marshaler {
	return ec._ApplicationMetadata(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationMetadata2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplicationMetadata(ctx context.Context, sel ast.SelectionSet, v *ApplicationMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ApplicationMetadata(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCreateApplicationMetadataInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateApplicationMetadataInput(ctx context.Context, v interface{}) (CreateApplicationMetadataInput, error) {
	res, err := ec.unmarshalInputCreateApplicationMetadataInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateDatasourceInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateDatasourceInput(ctx context.Context, v interface{}) (CreateDatasourceInput, error) {
	res, err := ec.unmarshalInputCreateDatasourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateEmbedderInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateEmbedderInput(ctx context.Context, v interface{}) (CreateEmbedderInput, error) {
	res, err := ec.unmarshalInputCreateEmbedderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateKnowledgeBaseInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateKnowledgeBaseInput(ctx context.Context, v interface{}) (CreateKnowledgeBaseInput, error) {
	res, err := ec.unmarshalInputCreateKnowledgeBaseInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateModelInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateModelInput(ctx context.Context, v interface{}) (CreateModelInput, error) {
	res, err := ec.unmarshalInputCreateModelInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateModelServiceInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateModelServiceInput(ctx context.Context, v interface{}) (CreateModelServiceInput, error) {
	res, err := ec.unmarshalInputCreateModelServiceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateVersionedDatasetInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateVersionedDatasetInput(ctx context.Context, v interface{}) (CreateVersionedDatasetInput, error) {
	res, err := ec.unmarshalInputCreateVersionedDatasetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateWorkerInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateWorkerInput(ctx context.Context, v interface{}) (CreateWorkerInput, error) {
	res, err := ec.unmarshalInputCreateWorkerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDataProcessConfig2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfig(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DataProcessConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDataProcessConfigItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigItem(ctx context.Context, v interface{}) (*DataProcessConfigItem, error) {
	res, err := ec.unmarshalInputDataProcessConfigItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDataProcessDetailsItem2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessDetailsItem(ctx context.Context, sel ast.SelectionSet, v DataProcessDetailsItem) graphql.Marshaler {
	return ec._DataProcessDetailsItem(ctx, sel, &v)
}

func (ec *executionContext) marshalNDataProcessItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessItem(ctx context.Context, sel ast.SelectionSet, v *DataProcessItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DataProcessItem(ctx, sel, v)
}

func (ec *executionContext) marshalNDataProcessSupportTypeChildren2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessSupportTypeChildren(ctx context.Context, sel ast.SelectionSet, v *DataProcessSupportTypeChildren) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DataProcessSupportTypeChildren(ctx, sel, v)
}

func (ec *executionContext) marshalNDataProcessSupportTypeItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessSupportTypeItem(ctx context.Context, sel ast.SelectionSet, v *DataProcessSupportTypeItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DataProcessSupportTypeItem(ctx, sel, v)
}

func (ec *executionContext) marshalNDataset2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataset(ctx context.Context, sel ast.SelectionSet, v Dataset) graphql.Marshaler {
	return ec._Dataset(ctx, sel, &v)
}

func (ec *executionContext) marshalNDataset2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataset(ctx context.Context, sel ast.SelectionSet, v *Dataset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Dataset(ctx, sel, v)
}

func (ec *executionContext) marshalNDatasource2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasource(ctx context.Context, sel ast.SelectionSet, v Datasource) graphql.Marshaler {
	return ec._Datasource(ctx, sel, &v)
}

func (ec *executionContext) marshalNDatasource2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasource(ctx context.Context, sel ast.SelectionSet, v *Datasource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Datasource(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteCommonInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteCommonInput(ctx context.Context, v interface{}) (DeleteCommonInput, error) {
	res, err := ec.unmarshalInputDeleteCommonInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDeleteVersionedDatasetInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteVersionedDatasetInput(ctx context.Context, v interface{}) (DeleteVersionedDatasetInput, error) {
	res, err := ec.unmarshalInputDeleteVersionedDatasetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEmbedder2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEmbedder(ctx context.Context, sel ast.SelectionSet, v Embedder) graphql.Marshaler {
	return ec._Embedder(ctx, sel, &v)
}

func (ec *executionContext) marshalNEmbedder2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEmbedder(ctx context.Context, sel ast.SelectionSet, v *Embedder) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Embedder(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEndpointInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpointInput(ctx context.Context, v interface{}) (EndpointInput, error) {
	res, err := ec.unmarshalInputEndpointInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFileGroup2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileGroup(ctx context.Context, v interface{}) (*FileGroup, error) {
	res, err := ec.unmarshalInputFileGroup(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFileItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileItem(ctx context.Context, v interface{}) (*FileItem, error) {
	res, err := ec.unmarshalInputFileItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNKnowledgeBase2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐKnowledgeBase(ctx context.Context, sel ast.SelectionSet, v KnowledgeBase) graphql.Marshaler {
	return ec._KnowledgeBase(ctx, sel, &v)
}

func (ec *executionContext) marshalNKnowledgeBase2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐKnowledgeBase(ctx context.Context, sel ast.SelectionSet, v *KnowledgeBase) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._KnowledgeBase(ctx, sel, v)
}

func (ec *executionContext) marshalNLLM2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐLlm(ctx context.Context, sel ast.SelectionSet, v Llm) graphql.Marshaler {
	return ec._LLM(ctx, sel, &v)
}

func (ec *executionContext) marshalNLLM2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐLlm(ctx context.Context, sel ast.SelectionSet, v *Llm) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LLM(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListCommonInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListCommonInput(ctx context.Context, v interface{}) (ListCommonInput, error) {
	res, err := ec.unmarshalInputListCommonInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNListKnowledgeBaseInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListKnowledgeBaseInput(ctx context.Context, v interface{}) (ListKnowledgeBaseInput, error) {
	res, err := ec.unmarshalInputListKnowledgeBaseInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNListModelInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListModelInput(ctx context.Context, v interface{}) (ListModelInput, error) {
	res, err := ec.unmarshalInputListModelInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNListVersionedDatasetInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListVersionedDatasetInput(ctx context.Context, v interface{}) (ListVersionedDatasetInput, error) {
	res, err := ec.unmarshalInputListVersionedDatasetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNListWorkerInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListWorkerInput(ctx context.Context, v interface{}) (ListWorkerInput, error) {
	res, err := ec.unmarshalInputListWorkerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNModel2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModel(ctx context.Context, sel ast.SelectionSet, v Model) graphql.Marshaler {
	return ec._Model(ctx, sel, &v)
}

func (ec *executionContext) marshalNModel2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModel(ctx context.Context, sel ast.SelectionSet, v *Model) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Model(ctx, sel, v)
}

func (ec *executionContext) marshalNModelService2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelService(ctx context.Context, sel ast.SelectionSet, v ModelService) graphql.Marshaler {
	return ec._ModelService(ctx, sel, &v)
}

func (ec *executionContext) marshalNModelService2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelService(ctx context.Context, sel ast.SelectionSet, v *ModelService) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ModelService(ctx, sel, v)
}

func (ec *executionContext) marshalNPageNode2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPageNode(ctx context.Context, sel ast.SelectionSet, v PageNode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageNode(ctx, sel, v)
}

func (ec *executionContext) marshalNPaginatedResult2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx context.Context, sel ast.SelectionSet, v PaginatedResult) graphql.Marshaler {
	return ec._PaginatedResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNPaginatedResult2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedResult(ctx context.Context, sel ast.SelectionSet, v *PaginatedResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PaginatedResult(ctx, sel, v)
}

func (ec *executionContext) marshalNResources2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐResources(ctx context.Context, sel ast.SelectionSet, v Resources) graphql.Marshaler {
	return ec._Resources(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNResourcesInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐResourcesInput(ctx context.Context, v interface{}) (ResourcesInput, error) {
	res, err := ec.unmarshalInputResourcesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTypedObjectReference2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReference(ctx context.Context, sel ast.SelectionSet, v TypedObjectReference) graphql.Marshaler {
	return ec._TypedObjectReference(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNTypedObjectReferenceInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReferenceInput(ctx context.Context, v interface{}) (TypedObjectReferenceInput, error) {
	res, err := ec.unmarshalInputTypedObjectReferenceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateApplicationConfigInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateApplicationConfigInput(ctx context.Context, v interface{}) (UpdateApplicationConfigInput, error) {
	res, err := ec.unmarshalInputUpdateApplicationConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateApplicationMetadataInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateApplicationMetadataInput(ctx context.Context, v interface{}) (UpdateApplicationMetadataInput, error) {
	res, err := ec.unmarshalInputUpdateApplicationMetadataInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateVersionedDatasetInput2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateVersionedDatasetInput(ctx context.Context, v interface{}) (UpdateVersionedDatasetInput, error) {
	res, err := ec.unmarshalInputUpdateVersionedDatasetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionedDataset2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐVersionedDataset(ctx context.Context, sel ast.SelectionSet, v VersionedDataset) graphql.Marshaler {
	return ec._VersionedDataset(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersionedDataset2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐVersionedDataset(ctx context.Context, sel ast.SelectionSet, v *VersionedDataset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VersionedDataset(ctx, sel, v)
}

func (ec *executionContext) marshalNWorker2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐWorker(ctx context.Context, sel ast.SelectionSet, v Worker) graphql.Marshaler {
	return ec._Worker(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorker2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐWorker(ctx context.Context, sel ast.SelectionSet, v *Worker) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Worker(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNfilegroupinput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFilegroupinput(ctx context.Context, v interface{}) (*Filegroupinput, error) {
	res, err := ec.unmarshalInputfilegroupinput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAddDataProcessInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐAddDataProcessInput(ctx context.Context, v interface{}) (*AddDataProcessInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAddDataProcessInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAllDataProcessListByCountInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐAllDataProcessListByCountInput(ctx context.Context, v interface{}) (*AllDataProcessListByCountInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAllDataProcessListByCountInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAllDataProcessListByPageInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐAllDataProcessListByPageInput(ctx context.Context, v interface{}) (*AllDataProcessListByPageInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAllDataProcessListByPageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOApplicationMetadata2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplicationMetadata(ctx context.Context, sel ast.SelectionSet, v *ApplicationMetadata) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplicationMutation(ctx context.Context, sel ast.SelectionSet, v *ApplicationMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐApplicationQuery(ctx context.Context, sel ast.SelectionSet, v *ApplicationQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCheckDataProcessTaskNameInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCheckDataProcessTaskNameInput(ctx context.Context, v interface{}) (*CheckDataProcessTaskNameInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCheckDataProcessTaskNameInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCountDataProcessItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCountDataProcessItem(ctx context.Context, sel ast.SelectionSet, v *CountDataProcessItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CountDataProcessItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCreateDatasetInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐCreateDatasetInput(ctx context.Context, v interface{}) (*CreateDatasetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateDatasetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODataProcessConfig2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigᚄ(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDataProcessConfig2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODataProcessConfigChildren2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigChildren(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfigChildren) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODataProcessConfigChildren2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigChildren(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODataProcessConfigChildren2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigChildren(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfigChildren) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessConfigChildren(ctx, sel, v)
}

func (ec *executionContext) unmarshalODataProcessConfigItem2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigItemᚄ(ctx context.Context, v interface{}) ([]*DataProcessConfigItem, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*DataProcessConfigItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDataProcessConfigItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODataProcessConfigpreFileProgress2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreFileProgress(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfigpreFileProgress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODataProcessConfigpreFileProgress2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreFileProgress(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODataProcessConfigpreFileProgress2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreFileProgress(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfigpreFileProgress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessConfigpreFileProgress(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessConfigpreView2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreView(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfigpreView) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODataProcessConfigpreView2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreView(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODataProcessConfigpreView2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreView(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfigpreView) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessConfigpreView(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessConfigpreViewContent2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreViewContent(ctx context.Context, sel ast.SelectionSet, v []*DataProcessConfigpreViewContent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODataProcessConfigpreViewContent2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreViewContent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODataProcessConfigpreViewContent2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessConfigpreViewContent(ctx context.Context, sel ast.SelectionSet, v *DataProcessConfigpreViewContent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessConfigpreViewContent(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessDetails2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessDetails(ctx context.Context, sel ast.SelectionSet, v *DataProcessDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalODataProcessDetailsInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessDetailsInput(ctx context.Context, v interface{}) (*DataProcessDetailsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDataProcessDetailsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODataProcessItem2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*DataProcessItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDataProcessItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODataProcessMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessMutation(ctx context.Context, sel ast.SelectionSet, v *DataProcessMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessMutation(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessQuery(ctx context.Context, sel ast.SelectionSet, v *DataProcessQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessQuery(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessResponse2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessResponse(ctx context.Context, sel ast.SelectionSet, v *DataProcessResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessResponse(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessSupportType2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessSupportType(ctx context.Context, sel ast.SelectionSet, v *DataProcessSupportType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DataProcessSupportType(ctx, sel, v)
}

func (ec *executionContext) marshalODataProcessSupportTypeChildren2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessSupportTypeChildrenᚄ(ctx context.Context, sel ast.SelectionSet, v []*DataProcessSupportTypeChildren) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDataProcessSupportTypeChildren2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessSupportTypeChildren(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODataProcessSupportTypeItem2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessSupportTypeItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*DataProcessSupportTypeItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDataProcessSupportTypeItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDataProcessSupportTypeItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODatasetMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasetMutation(ctx context.Context, sel ast.SelectionSet, v *DatasetMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DatasetMutation(ctx, sel, v)
}

func (ec *executionContext) marshalODatasetQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasetQuery(ctx context.Context, sel ast.SelectionSet, v *DatasetQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DatasetQuery(ctx, sel, v)
}

func (ec *executionContext) marshalODatasourceMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasourceMutation(ctx context.Context, sel ast.SelectionSet, v *DatasourceMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DatasourceMutation(ctx, sel, v)
}

func (ec *executionContext) marshalODatasourceQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDatasourceQuery(ctx context.Context, sel ast.SelectionSet, v *DatasourceQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DatasourceQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalODeleteCommonInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteCommonInput(ctx context.Context, v interface{}) (*DeleteCommonInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDeleteCommonInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODeleteDataProcessInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐDeleteDataProcessInput(ctx context.Context, v interface{}) (*DeleteDataProcessInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDeleteDataProcessInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEmbedderMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEmbedderMutation(ctx context.Context, sel ast.SelectionSet, v *EmbedderMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EmbedderMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOEmbedderQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEmbedderQuery(ctx context.Context, sel ast.SelectionSet, v *EmbedderQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EmbedderQuery(ctx, sel, v)
}

func (ec *executionContext) marshalOEndpoint2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpoint(ctx context.Context, sel ast.SelectionSet, v *Endpoint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Endpoint(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEndpointInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐEndpointInput(ctx context.Context, v interface{}) (*EndpointInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEndpointInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFileFilter2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileFilter(ctx context.Context, v interface{}) (*FileFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFileFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFileGroup2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileGroup(ctx context.Context, v interface{}) ([]*FileGroup, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FileGroup, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFileGroup2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFileGroup2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileGroupᚄ(ctx context.Context, v interface{}) ([]*FileGroup, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FileGroup, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFileGroup2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFileGroup2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileGroup(ctx context.Context, v interface{}) (*FileGroup, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFileGroup(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFileItem2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileItemᚄ(ctx context.Context, v interface{}) ([]*FileItem, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FileItem, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFileItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFileItem(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOKnowledgeBaseMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐKnowledgeBaseMutation(ctx context.Context, sel ast.SelectionSet, v *KnowledgeBaseMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KnowledgeBaseMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOKnowledgeBaseQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐKnowledgeBaseQuery(ctx context.Context, sel ast.SelectionSet, v *KnowledgeBaseQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KnowledgeBaseQuery(ctx, sel, v)
}

func (ec *executionContext) marshalOLLMConfig2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐLLMConfig(ctx context.Context, sel ast.SelectionSet, v *LLMConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LLMConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLLMConfigItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐLLMConfigItem(ctx context.Context, v interface{}) (*LLMConfigItem, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLLMConfigItem(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLLMQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐLLMQuery(ctx context.Context, sel ast.SelectionSet, v *LLMQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LLMQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalOListDatasetInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListDatasetInput(ctx context.Context, v interface{}) (*ListDatasetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputListDatasetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOListModelServiceInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐListModelServiceInput(ctx context.Context, v interface{}) (*ListModelServiceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputListModelServiceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) marshalOModelMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelMutation(ctx context.Context, sel ast.SelectionSet, v *ModelMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ModelMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOModelQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelQuery(ctx context.Context, sel ast.SelectionSet, v *ModelQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ModelQuery(ctx, sel, v)
}

func (ec *executionContext) marshalOModelServiceMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelServiceMutation(ctx context.Context, sel ast.SelectionSet, v *ModelServiceMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ModelServiceMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOModelServiceQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐModelServiceQuery(ctx context.Context, sel ast.SelectionSet, v *ModelServiceQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ModelServiceQuery(ctx, sel, v)
}

func (ec *executionContext) marshalOOss2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐOss(ctx context.Context, sel ast.SelectionSet, v *Oss) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Oss(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOssInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐOssInput(ctx context.Context, v interface{}) (*OssInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOssInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPageNode2ᚕgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPageNodeᚄ(ctx context.Context, sel ast.SelectionSet, v []PageNode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPageNode2githubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPageNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPaginatedDataProcessItem2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐPaginatedDataProcessItem(ctx context.Context, sel ast.SelectionSet, v *PaginatedDataProcessItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PaginatedDataProcessItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalOResourcesInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐResourcesInput(ctx context.Context, v interface{}) (*ResourcesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputResourcesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTypedObjectReference2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReference(ctx context.Context, sel ast.SelectionSet, v *TypedObjectReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypedObjectReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTypedObjectReferenceInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐTypedObjectReferenceInput(ctx context.Context, v interface{}) (*TypedObjectReferenceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTypedObjectReferenceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateDatasetInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateDatasetInput(ctx context.Context, v interface{}) (*UpdateDatasetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateDatasetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateDatasourceInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateDatasourceInput(ctx context.Context, v interface{}) (*UpdateDatasourceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateDatasourceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateEmbedderInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateEmbedderInput(ctx context.Context, v interface{}) (*UpdateEmbedderInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateEmbedderInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateKnowledgeBaseInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateKnowledgeBaseInput(ctx context.Context, v interface{}) (*UpdateKnowledgeBaseInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateKnowledgeBaseInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateModelInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateModelInput(ctx context.Context, v interface{}) (*UpdateModelInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateModelInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateModelServiceInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateModelServiceInput(ctx context.Context, v interface{}) (*UpdateModelServiceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateModelServiceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateWorkerInput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐUpdateWorkerInput(ctx context.Context, v interface{}) (*UpdateWorkerInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateWorkerInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersionedDatasetMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐVersionedDatasetMutation(ctx context.Context, sel ast.SelectionSet, v *VersionedDatasetMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VersionedDatasetMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOVersionedDatasetQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐVersionedDatasetQuery(ctx context.Context, sel ast.SelectionSet, v *VersionedDatasetQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VersionedDatasetQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVoid2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVoid2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOWorkerMutation2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐWorkerMutation(ctx context.Context, sel ast.SelectionSet, v *WorkerMutation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkerMutation(ctx, sel, v)
}

func (ec *executionContext) marshalOWorkerQuery2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐWorkerQuery(ctx context.Context, sel ast.SelectionSet, v *WorkerQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkerQuery(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) marshalOfiledetail2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFiledetail(ctx context.Context, sel ast.SelectionSet, v []*Filedetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOfiledetail2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFiledetail(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOfiledetail2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFiledetail(ctx context.Context, sel ast.SelectionSet, v *Filedetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._filedetail(ctx, sel, v)
}

func (ec *executionContext) marshalOfilegroupdetail2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFilegroupdetail(ctx context.Context, sel ast.SelectionSet, v []*Filegroupdetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOfilegroupdetail2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFilegroupdetail(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOfilegroupdetail2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFilegroupdetail(ctx context.Context, sel ast.SelectionSet, v *Filegroupdetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._filegroupdetail(ctx, sel, v)
}

func (ec *executionContext) unmarshalOfilegroupinput2ᚕᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFilegroupinputᚄ(ctx context.Context, v interface{}) ([]*Filegroupinput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*Filegroupinput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNfilegroupinput2ᚖgithubᚗcomᚋkubeagiᚋarcadiaᚋapiserverᚋgraphᚋgeneratedᚐFilegroupinput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

// endregion ***************************** type.gotpl *****************************
